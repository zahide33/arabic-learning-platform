from collections import defaultdict
from datetime import datetime, timedelta
import json
import os
import random
import re
import shutil
import sqlite3
import threading
import time
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
import warnings

from PIL import Image, ImageTk
from gtts import gTTS
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
import pygame

warnings.filterwarnings("ignore", category=UserWarning, module="pygame")

# Çoklu dil desteği için metinler
LANGUAGES = {
    "tr": {
        "app_title": "Arapça Öğrenme Platformu",
        "data_entry": "Veri Girme",
        "practice": "Kelime Çalışması",
        "memorize": "Kelime Ezber",
        "flashcards": "Kelime Kartları",
        "sentence_practice": "Cümle Çalışması",
        "exam_mode": "Sınav Modu",
        "management": "Yönetim",
        "statistics": "İstatistikler",
        "backup": "Yedekleme",
        "settings": "Ayarlar",
        "back": "← Geri",
        "add_single_word": "Tekil Kelime Ekle",
        "add_bulk_words": "Toplu Kelime Ekle",
        "add_sentence": "Cümle Ekle",
        "turkish_word": "Türkçe Kelime:",
        "arabic_word": "Arapça Kelime:",
        "category": "Kategori:",
        "new_category": "Yeni Kategori (isteğe bağlı):",
        "difficulty": "Zorluk Seviyesi (1-5):",
        "notes": "Notlar (isteğe bağlı):",
        "select_image": "Resim Seç:",
        "browse": "Gözat",
        "save": "Kaydet",
        "turkish_sentence": "Türkçe Cümle:",
        "arabic_sentence": "Arapça Cümle:",
        "word_practice": "Kelime Çalışması",
        "start": "Başlat",
        "question": "Soru",
        "correct": "Doğru",
        "wrong": "Yanlış",
        "next": "Sonraki",
        "select_category": "Başlamak için bir kategori seçip 'Başla' butonuna tıklayın",
        "light_theme": "Açık Tema",
        "dark_theme": "Koyu Tema",
        "blue_theme": "Mavi Tema",
        "green_theme": "Yeşil Tema",
        "language": "Dil:",
        "theme": "Tema:",
        "listen_again": "Tekrar Dinle",
        "create_category": "Kategori Oluştur",
        "category_name": "Kategori Adı:",
        "slayt_mode": "Slayt Modu",
        "manuel_mode": "Manuel Mod",
        "transition_time": "Geçiş Süresi (saniye):",
        "delete_category": "Kategori Sil",
        "edit_word": "Kelime Düzenle",
        "edit_sentence": "Cümle Düzenle",
        "pause": "Duraklat",
        "resume": "Devam Et",
        "finish": "Bitir",
        "previous": "Önceki",
        "profile_management": "Profil Yönetimi",
        "add_profile": "Profil Ekle",
        "delete_profile": "Profil Sil",
        "select_profile": "Profil Seç:",
        "profile_name": "Profil Adı:",
        "current_profile": "Mevcut Profil:",
        "no_profiles": "Hiç profil bulunamadı",
        "confirm_delete": "Silmek istediğinizden emin misiniz?",
        "category_not_empty": "Bu kategori boş değil ve silinemez.",
        "category_deleted": "Kategori başarıyla silindi.",
        "word_updated": "Kelime başarıyla güncellendi.",
        "sentence_updated": "Cümle başarıyla güncellendi.",
        "file_permission_error": "Dosya izin hatası: Lütfen dosyanın başka bir uygulama tarafından kullanılmadığından emin olun.",
        "word_practice_instruction": "Sesli kelimeyi dinleyin ve doğru olduğunu düşündüğünüzü seçin.",
        "show_answer": "Cevabı Göster",
        "practice_completed": "Çalışma Tamamlandı!",
        "total_questions": "Toplam Soru:",
        "correct_answers": "Doğru Cevaplar:",
        "wrong_answers": "Yanlış Cevaplar:",
        "success_rate": "Başarı Oranı:",
        "no_words_found": "Bu kategoride kelime bulunamadı!",
        "no_sentences_found": "Bu kategoride cümle bulunamadı!",
        "memorize_completed": "Ezber Tamamlandı!",
        "total_words": "Toplam Kelime:",
        "flashcards_completed": "Kartlar Tamamlandı!",
        "total_cards": "Toplam Kart:",
        "exam_completed": "Sınav Tamamlandı!",
        "total_exam_questions": "Toplam Soru:",
        "correct_exam_answers": "Doğru Cevaplar:",
        "wrong_exam_answers": "Yanlış Cevaplar:",
        "exam_time": "Sınav Süresi:",
        "exam_success_rate": "Sınav Başarısı:",
        "daily_stats": "Günlük İstatistikler",
        "weekly_stats": "Haftalık İstatistikler",
        "category_stats": "Kategori İstatistikleri",
        "no_stats_available": "Gösterilecek istatistik bulunamadı.",
        "general_stats": "Genel İstatistikler",
        "profile": "Profil:",
        "level": "Seviye:",
        "experience": "Deneyim:",
        "total_time": "Toplam Süre:",
        "words_learned": "Öğrenilen Kelimeler:",
        "sentences_learned": "Öğrenilen Cümleler:",
        "exam_results": "Sınav Sonuçları:",
        "last_exams": "Son Sınavlar:",
        "exam_type": "Sınav Türü:",
        "exam_score": "Sınav Puanı:",
        "exam_date": "Sınav Tarihi:",
        "word_practice_stats": "Kelime Çalışma İstatistikleri",
        "sentence_practice_stats": "Cümle Çalışma İstatistikleri",
        "exam_stats": "Sınav İstatistikleri",
        "memorize_stats": "Ezber İstatistikleri",
        "flashcards_stats": "Kart İstatistikleri",
        "total_practice_time": "Toplam Çalışma Süresi:",
        "average_success_rate": "Ortalama Başarı Oranı:",
        "most_difficult_words": "En Zor Kelimeler:",
        "most_difficult_categories": "En Zor Kategoriler:",
        "progress_over_time": "Zaman İlerlemesi:",
        "daily_progress": "Günlük İlerleme:",
        "weekly_progress": "Haftalık İlerleme:",
        "monthly_progress": "Aylık İlerleme:",
        "learning_trends": "Öğrenme Eğilimleri:",
        "category_performance": "Kategori Performansı:",
        "word_performance": "Kelime Performansı:",
        "sentence_performance": "Cümle Performansı:",
        "exam_performance": "Sınav Performansı:",
        "memorize_performance": "Ezber Performansı:",
        "flashcards_performance": "Kart Performansı:",
        "overall_performance": "Genel Performans:",
        "performance_comparison": "Performans Karşılaştırması:",
        "profile_comparison": "Profil Karşılaştırması:",
        "category_comparison": "Kategori Karşılaştırması:",
        "word_comparison": "Kelime Karşılaştırması:",
        "sentence_comparison": "Cümle Karşılaştırması:",
        "exam_comparison": "Sınav Karşılaştırması:",
        "memorize_comparison": "Ezber Karşılaştırması:",
        "flashcards_comparison": "Kart Karşılaştırması:",
        "time_comparison": "Zaman Karşılaştırması:",
        "success_rate_comparison": "Başarı Oranı Karşılaştırması:",
        "difficulty_comparison": "Zorluk Karşılaştırması:",
        "progress_comparison": "İlerleme Karşılaştırması:",
        "trend_comparison": "Eğilim Karşılaştırması:",
        "performance_trend": "Performans Eğilimi:",
        "learning_trend": "Öğrenme Eğilimi:",
        "difficulty_trend": "Zorluk Eğilimi:",
        "progress_trend": "İlerleme Eğilimi:",
        "time_trend": "Zaman Eğilimi:",
        "success_rate_trend": "Başarı Oranı Eğilimi:",
        "category_trend": "Kategori Eğilimi:",
        "word_trend": "Kelime Eğilimi:",
        "sentence_trend": "Cümle Eğilimi:",
        "exam_trend": "Sınav Eğilimi:",
        "memorize_trend": "Ezber Eğilimi:",
        "flashcards_trend": "Kart Eğilimi:",
        "overall_trend": "Genel Eğilim:",
        "profile_trend": "Profil Eğilimi:",
        "comparison_trend": "Karşılaştırma Eğilimi:",
        "performance_analysis": "Performans Analizi:",
        "learning_analysis": "Öğrenme Analizi:",
        "difficulty_analysis": "Zorluk Analizi:",
        "progress_analysis": "İlerleme Analizi:",
        "time_analysis": "Zaman Analizi:",
        "success_rate_analysis": "Başarı Oranı Analizi:",
        "category_analysis": "Kategori Analizi:",
        "word_analysis": "Kelime Analizi:",
        "sentence_analysis": "Cümle Analizi:",
        "exam_analysis": "Sınav Analizi:",
        "memorize_analysis": "Ezber Analizi:",
        "flashcards_analysis": "Kart Analizi:",
        "overall_analysis": "Genel Analiz:",
        "profile_analysis": "Profil Analizi:",
        "comparison_analysis": "Karşılaştırma Analizi:",
        "trend_analysis": "Eğilim Analizi:",
        "performance_report": "Performans Raporu:",
        "learning_report": "Öğrenme Raporu:",
        "difficulty_report": "Zorluk Raporu:",
        "progress_report": "İlerleme Raporu:",
        "time_report": "Zaman Raporu:",
        "success_rate_report": "Başarı Oranı Raporu:",
        "category_report": "Kategori Raporu:",
        "word_report": "Kelime Raporu:",
        "sentence_report": "Cümle Raporu:",
        "exam_report": "Sınav Raporu:",
        "memorize_report": "Ezber Raporu:",
        "flashcards_report": "Kart Raporu:",
        "overall_report": "Genel Rapor:",
        "profile_report": "Profil Raporu:",
        "comparison_report": "Karşılaştırma Raporu:",
        "trend_report": "Eğilim Raporu:",
        "export_stats": "İstatistikleri Dışa Aktar",
        "import_stats": "İstatistikleri İçe Aktar",
        "reset_stats": "İstatistikleri Sıfırla",
        "stats_exported": "İstatistikler başarıyla dışa aktarıldı.",
        "stats_imported": "İstatistikler başarıyla içe aktarıldı.",
        "stats_reset": "İstatistikler başarıyla sıfırlandı.",
        "export_error": "İstatistikler dışa aktarılırken hata oluştu.",
        "import_error": "İstatistikler içe aktarılırken hata oluştu.",
        "reset_error": "İstatistikler sıfırlanırken hata oluştu.",
        "select_export_file": "Dışa Aktarma Dosyasını Seç",
        "select_import_file": "İçe Aktarma Dosyasını Seç",
        "confirm_reset": "İstatistikleri sıfırlamak istediğinizden emin misiniz?",
        "stats_file": "İstatistik Dosyası",
        "json_files": "JSON Dosyaları",
        "csv_files": "CSV Dosyaları",
        "all_files": "Tüm Dosyalar",
        "no_data_to_export": "Dışa aktarılacak veri bulunamadı.",
        "invalid_import_file": "Geçersiz içe aktarma dosyası.",
        "import_success": "İçe aktarma başarılı.",
        "export_success": "Dışa aktarma başarılı.",
        "reset_success": "Sıfırlama başarılı.",
        "operation_failed": "İşlem başarısız.",
        "try_again": "Lütfen tekrar deneyin.",
        "contact_support": "Destek ekibiyle iletişime geçin.",
        "error_occurred": "Hata oluştu.",
        "unknown_error": "Bilinmeyen hata.",
        "file_not_found": "Dosya bulunamadı.",
        "permission_denied": "İzin reddedildi.",
        "disk_full": "Disk dolu.",
        "network_error": "Ağ hatası.",
        "server_error": "Sunucu hatası.",
        "timeout": "Zaman aşımı.",
        "invalid_data": "Geçersiz veri.",
        "data_corrupted": "Veri bozuk.",
        "operation_canceled": "İşlem iptal edildi.",
        "operation_completed": "İşlem tamamlandı.",
        "operation_in_progress": "İşlem devam ediyor.",
        "please_wait": "Lütfen bekleyin.",
        "processing": "İşleniyor...",
        "loading": "Yükleniyor...",
        "saving": "Kaydediliyor...",
        "deleting": "Siliniyor...",
        "updating": "Güncelleniyor...",
        "searching": "Aranıyor...",
        "filtering": "Filtreleniyor...",
        "sorting": "Sıralanıyor...",
        "exporting": "Dışa aktarılıyor...",
        "importing": "İçe aktarılıyor...",
        "resetting": "Sıfırlanıyor...",
        "analyzing": "Analiz ediliyor...",
        "generating": "Oluşturuluyor...",
        "displaying": "Gösteriliyor...",
        "refreshing": "Yenileniyor...",
        "synchronizing": "Senkronize ediliyor...",
        "backing_up": "Yedekleniyor...",
        "restoring": "Geri yükleniyor...",
        "optimizing": "Optimize ediliyor...",
        "validating": "Doğrulanıyor...",
        "verifying": "Doğrulanıyor...",
        "checking": "Kontrol ediliyor...",
        "testing": "Test ediliyor...",
        "debugging": "Hata ayıklanıyor...",
        "fixing": "Düzeltiliyor...",
        "repairing": "Onarılıyor...",
        "recovering": "Kurtarılıyor...",
        "cleaning": "Temizleniyor...",
        "organizing": "Organize ediliyor...",
        "categorizing": "Kategorize ediliyor...",
        "tagging": "Etiketleniyor...",
        "labeling": "Etiketleniyor...",
        "grouping": "Gruplanıyor...",
        "sorting_by_name": "İsme göre sıralanıyor...",
        "sorting_by_date": "Tarihe göre sıralanıyor...",
        "sorting_by_size": "Boyuta göre sıralanıyor...",
        "sorting_by_type": "Türe göre sıralanıyor...",
        "sorting_by_category": "Kategoriye göre sıralanıyor...",
        "sorting_by_difficulty": "Zorluğa göre sıralanıyor...",
        "sorting_by_progress": "İlerlemeye göre sıralanıyor...",
        "sorting_by_performance": "Performansa göre sıralanıyor...",
        "sorting_by_time": "Zamana göre sıralanıyor...",
        "sorting_by_success_rate": "Başarı oranına göre sıralanıyor...",
        "sorting_by_frequency": "Sıklığa göre sıralanıyor...",
        "sorting_by_relevance": "İlgiye göre sıralanıyor...",
        "sorting_by_priority": "Önceliğe göre sıralanıyor...",
        "sorting_by_status": "Duruma göre sıralanıyor...",
        "sorting_by_owner": "Sahibine göre sıralanıyor...",
        "sorting_by_location": "Konuma göre sıralanıyor...",
        "sorting_by_rating": "Değerlendirmeye göre sıralanıyor...",
        "sorting_by_views": "Görüntülenmeye göre sıralanıyor...",
        "sorting_by_downloads": "İndirmeye göre sıralanıyor...",
        "sorting_by_likes": "Beğeniye göre sıralanıyor...",
        "sorting_by_dislikes": "Beğenmemeye göre sıralanıyor...",
        "sorting_by_comments": "Yoruma göre sıralanıyor...",
        "sorting_by_shares": "Paylaşıma göre sıralanıyor...",
        "sorting_by_followers": "Takipçiye göre sıralanıyor...",
        "sorting_by_following": "Takip edilenlere göre sıralanıyor...",
        "sorting_by_friends": "Arkadaşa göre sıralanıyor...",
        "sorting_by_family": "Aileye göre sıralanıyor...",
        "sorting_by_colleagues": "Meslektaşa göre sıralanıyor...",
        "sorting_by_classmates": "Sınıf arkadaşına göre sıralanıyor...",
        "sorting_by_teammates": "Takım arkadaşına göre sıralanıyor...",
        "sorting_by_partners": "Ortağa göre sıralanıyor...",
        "sorting_by_clients": "Müşteriye göre sıralanıyor...",
        "sorting_by_customers": "Müşteriye göre sıralanıyor...",
        "sorting_by_users": "Kullanıcıya göre sıralanıyor...",
        "sorting_by_members": "Üyeye göre sıralanıyor...",
        "sorting_by_subscribers": "Aboneye göre sıralanıyor...",
        "sorting_by_visitors": "Ziyaretçiye göre sıralanıyor...",
        "sorting_by_guests": "Misafire göre sıralanıyor...",
        "sorting_by_attendees": "Katılımcıya göre sıralanıyor...",
        "sorting_by_participants": "Katılımcıya göre sıralanıyor...",
        "sorting_by_volunteers": "Gönüllüye göre sıralanıyor...",
        "sorting_by_employees": "Çalışana göre sıralanıyor...",
        "sorting_by_employers": "İşverene göre sıralanıyor...",
        "sorting_by_applicants": "Başvurana göre sıralanıyor...",
        "sorting_by_candidates": "Adaya göre sıralanıyor...",
        "sorting_by_interviewees": "Görüşülen kişiye göre sıralanıyor...",
        "sorting_by_hires": "İşe alınana göre sıralanıyor...",
        "sorting_by_fires": "Kovulana göre sıralanıyor...",
        "sorting_by_resignations": "İstifaya göre sıralanıyor...",
        "sorting_by_retirements": "Emekliliğe göre sıralanıyor...",
        "sorting_by_promotions": "Terfiye göre sıralanıyor...",
        "sorting_by_demotions": "Terfi düşürmeye göre sıralanıyor...",
        "sorting_by_transfers": "Nakle göre sıralanıyor...",
        "sorting_by_relocations": "Yer değiştirmeye göre sıralanıyor...",
        "sorting_by_travels": "Seyahate göre sıralanıyor...",
        "sorting_by_trips": "Geziye göre sıralanıyor...",
        "sorting_by_vacations": "Tatile göre sıralanıyor...",
        "sorting_by_holidays": "Tatile göre sıralanıyor...",
        "sorting_by_weekends": "Hafta sonuna göre sıralanıyor...",
        "sorting_by_weekdays": "Hafta içine göre sıralanıyor...",
        "sorting_by_mornings": "Sabaha göre sıralanıyor...",
        "sorting_by_afternoons": "Öğleden sonraya göre sıralanıyor...",
        "sorting_by_evenings": "Akşama göre sıralanıyor...",
        "sorting_by_nights": "Geceye göre sıralanıyor...",
        "sorting_by_midnights": "Gece yarısına göre sıralanıyor...",
        "sorting_by_dawns": "Şafağa göre sıralanıyor...",
        "sorting_by_noons": "Öğlene göre sıralanıyor...",
        "sorting_by_dusks": "Akşam karanlığına göre sıralanıyor...",
        "sorting_by_dawns": "Şafağa göre sıralanıyor...",
        "sorting_by_sunrises": "Gün doğumuna göre sıralanıyor...",
        "sorting_by_sunsets": "Gün batımına göre sıralanıyor...",
        "sorting_by_twilights": "Alacakaranlığa göre sıralanıyor...",
        "sorting_by_dusks": "Akşam karanlığına göre sıralanıyor...",
        "sorting_by_nightfalls": "Gece çöküşüne göre sıralanıyor...",
        "sorting_by_midnights": "Gece yarısına göre sıralanıyor...",
        "sorting_by_small_hours": "Gece geç saatlere göre sıralanıyor...",
        "sorting_by_early_hours": "Erken saatlere göre sıralanıyor...",
        "sorting_by_late_hours": "Geç saatlere göre sıralanıyor...",
        "sorting_by_rush_hours": "Yoğun saatlere göre sıralanıyor...",
        "sorting_by_peak_hours": "Doruk saatlere göre sıralanıyor...",
        "sorting_by_off_peak_hours": "Doruk dışı saatlere göre sıralanıyor...",
        "sorting_by_business_hours": "İş saatlerine göre sıralanıyor...",
        "sorting_by_office_hours": "Ofis saatlerine göre sıralanıyor...",
        "sorting_by_working_hours": "Çalışma saatlerine göre sıralanıyor...",
        "sorting_by_leisure_hours": "Boş zaman saatlerine göre sıralanıyor...",
        "sorting_by_free_time": "Boş zamana göre sıralanıyor...",
        "sorting_by_personal_time": "Kişisel zamana göre sıralanıyor...",
        "sorting_by_family_time": "Aile zamanına göre sıralanıyor...",
        "sorting_by_social_time": "Sosyal zamana göre sıralanıyor...",
        "sorting_by_alone_time": "Yalnız zamana göre sıralanıyor...",
        "sorting_by_group_time": "Grup zamanına göre sıralanıyor...",
        "sorting_by_team_time": "Takım zamanına göre sıralanıyor...",
        "sorting_by_pair_time": "İkili zamana göre sıralanıyor...",
        "sorting_by_solo_time": "Tekli zamana göre sıralanıyor...",
        "sorting_by_duo_time": "İkili zamana göre sıralanıyor...",
        "sorting_by_trio_time": "Üçlü zamana göre sıralanıyor...",
        "sorting_by_quartet_time": "Dörtlü zamana göre sıralanıyor...",
        "sorting_by_quintet_time": "Beşli zamana göre sıralanıyor...",
        "sorting_by_sextet_time": "Altılı zamana göre sıralanıyor...",
        "sorting_by_septet_time": "Yedili zamana göre sıralanıyor...",
        "sorting_by_octet_time": "Sekizli zamana göre sıralanıyor...",
        "sorting_by_nonet_time": "Dokuzlu zamana göre sıralanıyor...",
        "sorting_by_dectet_time": "Onlu zamana göre sıralanıyor...",
        "sorting_by_large_group_time": "Büyük grup zamanına göre sıralanıyor...",
        "sorting_by_small_group_time": "Küçük grup zamanına göre sıralanıyor...",
        "sorting_by_medium_group_time": "Orta grup zamanına göre sıralanıyor...",
        "sorting_by_very_large_group_time": "Çok büyük grup zamanına göre sıralanıyor...",
        "sorting_by_very_small_group_time": "Çok küçük grup zamanına göre sıralanıyor...",
        "sorting_by_huge_group_time": "Dev grup zamanına göre sıralanıyor...",
        "sorting_by_tiny_group_time": "Ufak grup zamanına göre sıralanıyor...",
        "sorting_by_massive_group_time": "Kütle grup zamanına göre sıralanıyor...",
        "sorting_by_miniscule_group_time": "Minicik grup zamanına göre sıralanıyor...",
        "sorting_by_gigantic_group_time": "Devasa grup zamanına göre sıralanıyor...",
        "sorting_by_microscopic_group_time": "Mikroskobik grup zamanına göre sıralanıyor...",
        "sorting_by_astronomical_group_time": "Astronomik grup zamanına göre sıralanıyor...",
        "sorting_by_infinite_group_time": "Sonsuz grup zamanına göre sıralanıyor...",
        "sorting_by_infinitesimal_group_time": "Sonsuz küçük grup zamanına göre sıralanıyor...",
        "sorting_by_immense_group_time": "Kocaman grup zamanına göre sıralanıyor...",
        "sorting_by_minuscule_group_time": "Minicik grup zamanına göre sıralanıyor...",
        "sorting_by_colossal_group_time": "Kolleksal grup zamanına göre sıralanıyor...",
        "sorting_by_tiny_group_time": "Ufak grup zamanına göre sıralanıyor...",
        "sorting_by_huge_group_time": "Dev grup zamanına göre sıralanıyor...",
        "sorting_by_massive_group_time": "Kütle grup zamanına göre sıralanıyor...",
        "sorting_by_gigantic_group_time": "Devasa grup zamanına göre sıralanıyor...",
        "sorting_by_microscopic_group_time": "Mikroskobik grup zamanına göre sıralanıyor...",
        "sorting_by_astronomical_group_time": "Astronomik grup zamanına göre sıralanıyor...",
        "sorting_by_infinite_group_time": "Sonsuz grup zamanına göre sıralanıyor...",
        "sorting_by_infinitesimal_group_time": "Sonsuz küçük grup zamanına göre sıralanıyor...",
        "sorting_by_immense_group_time": "Kocaman grup zamanına göre sıralanıyor...",
        "sorting_by_minuscule_group_time": "Minicik grup zamanına göre sıralanıyor...",
        "sorting_by_colossal_group_time": "Kolleksal grup zamanına göre sıralanıyor..."
    },
    "en": {
        "app_title": "Arabic Learning Platform",
        "data_entry": "Data Entry",
        "practice": "Word Practice",
        "memorize": "Word Memorization",
        "flashcards": "Flashcards",
        "sentence_practice": "Sentence Practice",
        "exam_mode": "Exam Mode",
        "management": "Management",
        "statistics": "Statistics",
        "backup": "Backup",
        "settings": "Settings",
        "back": "← Back",
        "add_single_word": "Add Single Word",
        "add_bulk_words": "Add Bulk Words",
        "add_sentence": "Add Sentence",
        "turkish_word": "Turkish Word:",
        "arabic_word": "Arabic Word:",
        "category": "Category:",
        "new_category": "New Category (optional):",
        "difficulty": "Difficulty Level (1-5):",
        "notes": "Notes (optional):",
        "select_image": "Select Image:",
        "browse": "Browse",
        "save": "Save",
        "turkish_sentence": "Turkish Sentence:",
        "arabic_sentence": "Arabic Sentence:",
        "word_practice": "Word Practice",
        "start": "Start",
        "question": "Question",
        "correct": "Correct",
        "wrong": "Wrong",
        "next": "Next",
        "select_category": "Select a category and click 'Start' to begin",
        "light_theme": "Light Theme",
        "dark_theme": "Dark Theme",
        "blue_theme": "Blue Theme",
        "green_theme": "Green Theme",
        "language": "Language:",
        "theme": "Theme:",
        "listen_again": "Listen Again",
        "create_category": "Create Category",
        "category_name": "Category Name:",
        "slayt_mode": "Slide Mode",
        "manuel_mode": "Manual Mode",
        "transition_time": "Transition Time (seconds):",
        "delete_category": "Delete Category",
        "edit_word": "Edit Word",
        "edit_sentence": "Edit Sentence",
        "pause": "Pause",
        "resume": "Resume",
        "finish": "Finish",
        "previous": "Previous",
        "profile_management": "Profile Management",
        "add_profile": "Add Profile",
        "delete_profile": "Delete Profile",
        "select_profile": "Select Profile:",
        "profile_name": "Profile Name:",
        "current_profile": "Current Profile:",
        "no_profiles": "No profiles found",
        "confirm_delete": "Are you sure you want to delete?",
        "category_not_empty": "This category is not empty and cannot be deleted.",
        "category_deleted": "Category successfully deleted.",
        "word_updated": "Word successfully updated.",
        "sentence_updated": "Sentence successfully updated.",
        "file_permission_error": "File permission error: Please make sure the file is not being used by another application.",
        "word_practice_instruction": "Listen to the audio word and select what you think is correct.",
        "show_answer": "Show Answer",
        "practice_completed": "Practice Completed!",
        "total_questions": "Total Questions:",
        "correct_answers": "Correct Answers:",
        "wrong_answers": "Wrong Answers:",
        "success_rate": "Success Rate:",
        "no_words_found": "No words found in this category!",
        "no_sentences_found": "No sentences found in this category!",
        "memorize_completed": "Memorization Completed!",
        "total_words": "Total Words:",
        "flashcards_completed": "Flashcards Completed!",
        "total_cards": "Total Cards:",
        "exam_completed": "Exam Completed!",
        "total_exam_questions": "Total Questions:",
        "correct_exam_answers": "Correct Answers:",
        "wrong_exam_answers": "Wrong Answers:",
        "exam_time": "Exam Time:",
        "exam_success_rate": "Exam Success:",
        "daily_stats": "Daily Statistics",
        "weekly_stats": "Weekly Statistics",
        "category_stats": "Category Statistics",
        "no_stats_available": "No statistics available to display.",
        "general_stats": "General Statistics",
        "profile": "Profile:",
        "level": "Level:",
        "experience": "Experience:",
        "total_time": "Total Time:",
        "words_learned": "Words Learned:",
        "sentences_learned": "Sentences Learned:",
        "exam_results": "Exam Results:",
        "last_exams": "Last Exams:",
        "exam_type": "Exam Type:",
        "exam_score": "Exam Score:",
        "exam_date": "Exam Date:",
        "word_practice_stats": "Word Practice Statistics",
        "sentence_practice_stats": "Sentence Practice Statistics",
        "exam_stats": "Exam Statistics",
        "memorize_stats": "Memorization Statistics",
        "flashcards_stats": "Flashcards Statistics",
        "total_practice_time": "Total Practice Time:",
        "average_success_rate": "Average Success Rate:",
        "most_difficult_words": "Most Difficult Words:",
        "most_difficult_categories": "Most Difficult Categories:",
        "progress_over_time": "Progress Over Time:",
        "daily_progress": "Daily Progress:",
        "weekly_progress": "Weekly Progress:",
        "monthly_progress": "Monthly Progress:",
        "learning_trends": "Learning Trends:",
        "category_performance": "Category Performance:",
        "word_performance": "Word Performance:",
        "sentence_performance": "Sentence Performance:",
        "exam_performance": "Exam Performance:",
        "memorize_performance": "Memorization Performance:",
        "flashcards_performance": "Flashcards Performance:",
        "overall_performance": "Overall Performance:",
        "performance_comparison": "Performance Comparison:",
        "profile_comparison": "Profile Comparison:",
        "category_comparison": "Category Comparison:",
        "word_comparison": "Word Comparison:",
        "sentence_comparison": "Sentence Comparison:",
        "exam_comparison": "Exam Comparison:",
        "memorize_comparison": "Memorization Comparison:",
        "flashcards_comparison": "Flashcards Comparison:",
        "time_comparison": "Time Comparison:",
        "success_rate_comparison": "Success Rate Comparison:",
        "difficulty_comparison": "Difficulty Comparison:",
        "progress_comparison": "Progress Comparison:",
        "trend_comparison": "Trend Comparison:",
        "performance_trend": "Performance Trend:",
        "learning_trend": "Learning Trend:",
        "difficulty_trend": "Difficulty Trend:",
        "progress_trend": "Progress Trend:",
        "time_trend": "Time Trend:",
        "success_rate_trend": "Success Rate Trend:",
        "category_trend": "Category Trend:",
        "word_trend": "Word Trend:",
        "sentence_trend": "Sentence Trend:",
        "exam_trend": "Exam Trend:",
        "memorize_trend": "Memorization Trend:",
        "flashcards_trend": "Flashcards Trend:",
        "overall_trend": "Overall Trend:",
        "profile_trend": "Profile Trend:",
        "comparison_trend": "Comparison Trend:",
        "performance_analysis": "Performance Analysis:",
        "learning_analysis": "Learning Analysis:",
        "difficulty_analysis": "Difficulty Analysis:",
        "progress_analysis": "Progress Analysis:",
        "time_analysis": "Time Analysis:",
        "success_rate_analysis": "Success Rate Analysis:",
        "category_analysis": "Category Analysis:",
        "word_analysis": "Word Analysis:",
        "sentence_analysis": "Sentence Analysis:",
        "exam_analysis": "Exam Analysis:",
        "memorize_analysis": "Memorization Analysis:",
        "flashcards_analysis": "Flashcards Analysis:",
        "overall_analysis": "Overall Analysis:",
        "profile_analysis": "Profile Analysis:",
        "comparison_analysis": "Comparison Analysis:",
        "trend_analysis": "Trend Analysis:",
        "performance_report": "Performance Report:",
        "learning_report": "Learning Report:",
        "difficulty_report": "Difficulty Report:",
        "progress_report": "Progress Report:",
        "time_report": "Time Report:",
        "success_rate_report": "Success Rate Report:",
        "category_report": "Category Report:",
        "word_report": "Word Report:",
        "sentence_report": "Sentence Report:",
        "exam_report": "Exam Report:",
        "memorize_report": "Memorization Report:",
        "flashcards_report": "Flashcards Report:",
        "overall_report": "Overall Report:",
        "profile_report": "Profile Report:",
        "comparison_report": "Comparison Report:",
        "trend_report": "Trend Report:",
        "export_stats": "Export Statistics",
        "import_stats": "Import Statistics",
        "reset_stats": "Reset Statistics",
        "stats_exported": "Statistics successfully exported.",
        "stats_imported": "Statistics successfully imported.",
        "stats_reset": "Statistics successfully reset.",
        "export_error": "Error occurred while exporting statistics.",
        "import_error": "Error occurred while importing statistics.",
        "reset_error": "Error occurred while resetting statistics.",
        "select_export_file": "Select Export File",
        "select_import_file": "Select Import File",
        "confirm_reset": "Are you sure you want to reset statistics?",
        "stats_file": "Statistics File",
        "json_files": "JSON Files",
        "csv_files": "CSV Files",
        "all_files": "All Files",
        "no_data_to_export": "No data to export.",
        "invalid_import_file": "Invalid import file.",
        "import_success": "Import successful.",
        "export_success": "Export successful.",
        "reset_success": "Reset successful.",
        "operation_failed": "Operation failed.",
        "try_again": "Please try again.",
        "contact_support": "Contact support team.",
        "error_occurred": "Error occurred.",
        "unknown_error": "Unknown error.",
        "file_not_found": "File not found.",
        "permission_denied": "Permission denied.",
        "disk_full": "Disk full.",
        "network_error": "Network error.",
        "server_error": "Server error.",
        "timeout": "Timeout.",
        "invalid_data": "Invalid data.",
        "data_corrupted": "Data corrupted.",
        "operation_canceled": "Operation canceled.",
        "operation_completed": "Operation completed.",
        "operation_in_progress": "Operation in progress.",
        "please_wait": "Please wait.",
        "processing": "Processing...",
        "loading": "Loading...",
        "saving": "Saving...",
        "deleting": "Deleting...",
        "updating": "Updating...",
        "searching": "Searching...",
        "filtering": "Filtering...",
        "sorting": "Sorting...",
        "exporting": "Exporting...",
        "importing": "Importing...",
        "resetting": "Resetting...",
        "analyzing": "Analyzing...",
        "generating": "Generating...",
        "displaying": "Displaying...",
        "refreshing": "Refreshing...",
        "synchronizing": "Synchronizing...",
        "backing_up": "Backing up...",
        "restoring": "Restoring...",
        "optimizing": "Optimizing...",
        "validating": "Validating...",
        "verifying": "Verifying...",
        "checking": "Checking...",
        "testing": "Testing...",
        "debugging": "Debugging...",
        "fixing": "Fixing...",
        "repairing": "Repairing...",
        "recovering": "Recovering...",
        "cleaning": "Cleaning...",
        "organizing": "Organizing...",
        "categorizing": "Categorizing...",
        "tagging": "Tagging...",
        "labeling": "Labeling...",
        "grouping": "Grouping...",
        "sorting_by_name": "Sorting by name...",
        "sorting_by_date": "Sorting by date...",
        "sorting_by_size": "Sorting by size...",
        "sorting_by_type": "Sorting by type...",
        "sorting_by_category": "Sorting by category...",
        "sorting_by_difficulty": "Sorting by difficulty...",
        "sorting_by_progress": "Sorting by progress...",
        "sorting_by_performance": "Sorting by performance...",
        "sorting_by_time": "Sorting by time...",
        "sorting_by_success_rate": "Sorting by success rate...",
        "sorting_by_frequency": "Sorting by frequency...",
        "sorting_by_relevance": "Sorting by relevance...",
        "sorting_by_priority": "Sorting by priority...",
        "sorting_by_status": "Sorting by status...",
        "sorting_by_owner": "Sorting by owner...",
        "sorting_by_location": "Sorting by location...",
        "sorting_by_rating": "Sorting by rating...",
        "sorting_by_views": "Sorting by views...",
        "sorting_by_downloads": "Sorting by downloads...",
        "sorting_by_likes": "Sorting by likes...",
        "sorting_by_dislikes": "Sorting by dislikes...",
        "sorting_by_comments": "Sorting by comments...",
        "sorting_by_shares": "Sorting by shares...",
        "sorting_by_followers": "Sorting by followers...",
        "sorting_by_following": "Sorting by following...",
        "sorting_by_friends": "Sorting by friends...",
        "sorting_by_family": "Sorting by family...",
        "sorting_by_colleagues": "Sorting by colleagues...",
        "sorting_by_classmates": "Sorting by classmates...",
        "sorting_by_teammates": "Sorting by teammates...",
        "sorting_by_partners": "Sorting by partners...",
        "sorting_by_clients": "Sorting by clients...",
        "sorting_by_customers": "Sorting by customers...",
        "sorting_by_users": "Sorting by users...",
        "sorting_by_members": "Sorting by members...",
        "sorting_by_subscribers": "Sorting by subscribers...",
        "sorting_by_visitors": "Sorting by visitors...",
        "sorting_by_guests": "Sorting by guests...",
        "sorting_by_attendees": "Sorting by attendees...",
        "sorting_by_participants": "Sorting by participants...",
        "sorting_by_volunteers": "Sorting by volunteers...",
        "sorting_by_employees": "Sorting by employees...",
        "sorting_by_employers": "Sorting by employers...",
        "sorting_by_applicants": "Sorting by applicants...",
        "sorting_by_candidates": "Sorting by candidates...",
        "sorting_by_interviewees": "Sorting by interviewees...",
        "sorting_by_hires": "Sorting by hires...",
        "sorting_by_fires": "Sorting by fires...",
        "sorting_by_resignations": "Sorting by resignations...",
        "sorting_by_retirements": "Sorting by retirements...",
        "sorting_by_promotions": "Sorting by promotions...",
        "sorting_by_demotions": "Sorting by demotions...",
        "sorting_by_transfers": "Sorting by transfers...",
        "sorting_by_relocations": "Sorting by relocations...",
        "sorting_by_travels": "Sorting by travels...",
        "sorting_by_trips": "Sorting by trips...",
        "sorting_by_vacations": "Sorting by vacations...",
        "sorting_by_holidays": "Sorting by holidays...",
        "sorting_by_weekends": "Sorting by weekends...",
        "sorting_by_weekdays": "Sorting by weekdays...",
        "sorting_by_mornings": "Sorting by mornings...",
        "sorting_by_afternoons": "Sorting by afternoons...",
        "sorting_by_evenings": "Sorting by evenings...",
        "sorting_by_nights": "Sorting by nights...",
        "sorting_by_midnights": "Sorting by midnights...",
        "sorting_by_dawns": "Sorting by dawns...",
        "sorting_by_noons": "Sorting by noons...",
        "sorting_by_dusks": "Sorting by dusks...",
        "sorting_by_dawns": "Sorting by dawns...",
        "sorting_by_sunrises": "Sorting by sunrises...",
        "sorting_by_sunsets": "Sorting by sunsets...",
        "sorting_by_twilights": "Sorting by twilights...",
        "sorting_by_dusks": "Sorting by dusks...",
        "sorting_by_nightfalls": "Sorting by nightfalls...",
        "sorting_by_midnights": "Sorting by midnights...",
        "sorting_by_small_hours": "Sorting by small hours...",
        "sorting_by_early_hours": "Sorting by early hours...",
        "sorting_by_late_hours": "Sorting by late hours...",
        "sorting_by_rush_hours": "Sorting by rush hours...",
        "sorting_by_peak_hours": "Sorting by peak hours...",
        "sorting_by_off_peak_hours": "Sorting by off-peak hours...",
        "sorting_by_business_hours": "Sorting by business hours...",
        "sorting_by_office_hours": "Sorting by office hours...",
        "sorting_by_working_hours": "Sorting by working hours...",
        "sorting_by_leisure_hours": "Sorting by leisure hours...",
        "sorting_by_free_time": "Sorting by free time...",
        "sorting_by_personal_time": "Sorting by personal time...",
        "sorting_by_family_time": "Sorting by family time...",
        "sorting_by_social_time": "Sorting by social time...",
        "sorting_by_alone_time": "Sorting by alone time...",
        "sorting_by_group_time": "Sorting by group time...",
        "sorting_by_team_time": "Sorting by team time...",
        "sorting_by_pair_time": "Sorting by pair time...",
        "sorting_by_solo_time": "Sorting by solo time...",
        "sorting_by_duo_time": "Sorting by duo time...",
        "sorting_by_trio_time": "Sorting by trio time...",
        "sorting_by_quartet_time": "Sorting by quartet time...",
        "sorting_by_quintet_time": "Sorting by quintet time...",
        "sorting_by_sextet_time": "Sorting by sextet time...",
        "sorting_by_septet_time": "Sorting by septet time...",
        "sorting_by_octet_time": "Sorting by octet time...",
        "sorting_by_nonet_time": "Sorting by nonet time...",
        "sorting_by_dectet_time": "Sorting by dectet time...",
        "sorting_by_large_group_time": "Sorting by large group time...",
        "sorting_by_small_group_time": "Sorting by small group time...",
        "sorting_by_medium_group_time": "Sorting by medium group time...",
        "sorting_by_very_large_group_time": "Sorting by very large group time...",
        "sorting_by_very_small_group_time": "Sorting by very small group time...",
        "sorting_by_huge_group_time": "Sorting by huge group time...",
        "sorting_by_tiny_group_time": "Sorting by tiny group time...",
        "sorting_by_massive_group_time": "Sorting by massive group time...",
        "sorting_by_miniscule_group_time": "Sorting by miniscule group time...",
        "sorting_by_gigantic_group_time": "Sorting by gigantic group time...",
        "sorting_by_microscopic_group_time": "Sorting by microscopic group time...",
        "sorting_by_astronomical_group_time": "Sorting by astronomical group time...",
        "sorting_by_infinite_group_time": "Sorting by infinite group time...",
        "sorting_by_infinitesimal_group_time": "Sorting by infinitesimal group time...",
        "sorting_by_immense_group_time": "Sorting by immense group time...",
        "sorting_by_minuscule_group_time": "Sorting by minuscule group time...",
        "sorting_by_colossal_group_time": "Sorting by colossal group time...",
        "sorting_by_tiny_group_time": "Sorting by tiny group time...",
        "sorting_by_huge_group_time": "Sorting by huge group time...",
        "sorting_by_massive_group_time": "Sorting by massive group time...",
        "sorting_by_gigantic_group_time": "Sorting by gigantic group time...",
        "sorting_by_microscopic_group_time": "Sorting by microscopic group time...",
        "sorting_by_astronomical_group_time": "Sorting by astronomical group time...",
        "sorting_by_infinite_group_time": "Sorting by infinite group time...",
        "sorting_by_infinitesimal_group_time": "Sorting by infinitesimal group time...",
        "sorting_by_immense_group_time": "Sorting by immense group time...",
        "sorting_by_minuscule_group_time": "Sorting by minuscule group time...",
        "sorting_by_colossal_group_time": "Sorting by colossal group time..."
    },
    "ar": {
        "app_title": "منصة تعلم اللغة العربية",
        "data_entry": "إدخال البيانات",
        "practice": "ممارسة الكلمات",
        "memorize": "حفظ الكلمات",
        "flashcards": "بطاقات تعليمية",
        "sentence_practice": "ممارسة الجمل",
        "exam_mode": "وضع الاختبار",
        "management": "الإدارة",
        "statistics": "الإحصائيات",
        "backup": "نسخ احتياطي",
        "settings": "الإعدادات",
        "back": "← رجوع",
        "add_single_word": "إضافة كلمة مفردة",
        "add_bulk_words": "إضافة كلمات متعددة",
        "add_sentence": "إضافة جملة",
        "turkish_word": "الكلمة التركية:",
        "arabic_word": "الكلمة العربية:",
        "category": "الفئة:",
        "new_category": "فئة جديدة (اختياري):",
        "difficulty": "مستوى الصعوبة (1-5):",
        "notes": "ملاحظات (اختياري):",
        "select_image": "اختر صورة:",
        "browse": "تصفح",
        "save": "حفظ",
        "turkish_sentence": "الجملة التركية:",
        "arabic_sentence": "الجملة العربية:",
        "word_practice": "ممارسة الكلمات",
        "start": "ابدأ",
        "question": "سؤال",
        "correct": "صحيح",
        "wrong": "خطأ",
        "next": "التالي",
        "select_category": "اختر فئة وانقر على 'ابدأ' للبدء",
        "light_theme": "سمة فاتحة",
        "dark_theme": "سمة داكنة",
        "blue_theme": "سمة زرقاء",
        "green_theme": "سمة خضراء",
        "language": "اللغة:",
        "theme": "السمة:",
        "listen_again": "استمع مرة أخرى",
        "create_category": "إنشاء فئة",
        "category_name": "اسم الفئة:",
        "slayt_mode": "وضع الشرائح",
        "manuel_mode": "الوضع اليدوي",
        "transition_time": "وقت الانتقال (ثواني):",
        "delete_category": "حذف الفئة",
        "edit_word": "تحرير الكلمة",
        "edit_sentence": "تحرير الجملة",
        "pause": "إيقاف مؤقت",
        "resume": "استئناف",
        "finish": "إنهاء",
        "previous": "السابق",
        "profile_management": "إدارة الملف الشخصي",
        "add_profile": "إضافة ملف شخصي",
        "delete_profile": "حذف الملف الشخصي",
        "select_profile": "اختر ملفًا شخصيًا:",
        "profile_name": "اسم الملف الشخصي:",
        "current_profile": "الملف الشخصي الحالي:",
        "no_profiles": "لم يتم العثور على ملفات شخصية",
        "confirm_delete": "هل أنت متأكد من أنك تريد الحذف؟",
        "category_not_empty": "هذه الفئة ليست فارغة ولا يمكن حذفها.",
        "category_deleted": "تم حذف الفئة بنجاح.",
        "word_updated": "تم تحديث الكلمة بنجاح.",
        "sentence_updated": "تم تحديث الجملة بنجاح.",
        "file_permission_error": "خطأ في إذن الملف: يرجى التأكد من أن الملف لا يتم استخدامه بواسطة تطبيق آخر.",
        "word_practice_instruction": "استمع إلى الكلمة الصوتية وحدد ما تعتقد أنه صحيح.",
        "show_answer": "إظهار الإجابة",
        "practice_completed": "اكتملت الممارسة!",
        "total_questions": "إجمالي الأسئلة:",
        "correct_answers": "الإجابات الصحيحة:",
        "wrong_answers": "الإجابات الخاطئة:",
        "success_rate": "معدل النجاح:",
        "no_words_found": "لم يتم العثور على كلمات في هذه الفئة!",
        "no_sentences_found": "لم يتم العثور على جمل في هذه الفئة!",
        "memorize_completed": "اكتمل الحفظ!",
        "total_words": "إجمالي الكلمات:",
        "flashcards_completed": "اكتملت البطاقات!",
        "total_cards": "إجمالي البطاقات:",
        "exam_completed": "اكتمل الاختبار!",
        "total_exam_questions": "إجمالي الأسئلة:",
        "correct_exam_answers": "الإجابات الصحيحة:",
        "wrong_exam_answers": "الإجابات الخاطئة:",
        "exam_time": "وقت الاختبار:",
        "exam_success_rate": "نجاح الاختبار:",
        "daily_stats": "إحصائيات يومية",
        "weekly_stats": "إحصائيات أسبوعية",
        "category_stats": "إحصائيات الفئة",
        "no_stats_available": "لا توجد إحصائيات متاحة للعرض.",
        "general_stats": "إحصائيات عامة",
        "profile": "الملف الشخصي:",
        "level": "المستوى:",
        "experience": "الخبرة:",
        "total_time": "إجمالي الوقت:",
        "words_learned": "الكلمات المتعلمة:",
        "sentences_learned": "الجمل المتعلمة:",
        "exam_results": "نتائج الاختبار:",
        "last_exams": "الاختبارات الأخيرة:",
        "exam_type": "نوع الاختبار:",
        "exam_score": "درجة الاختبار:",
        "exam_date": "تاريخ الاختبار:",
        "word_practice_stats": "إحصائيات ممارسة الكلمات",
        "sentence_practice_stats": "إحصائيات ممارسة الجمل",
        "exam_stats": "إحصائيات الاختبار",
        "memorize_stats": "إحصائيات الحفظ",
        "flashcards_stats": "إحصائيات البطاقات",
        "total_practice_time": "إجمالي وقت الممارسة:",
        "average_success_rate": "معدل النجاح المتوسط:",
        "most_difficult_words": "الكلمات الأكثر صعوبة:",
        "most_difficult_categories": "الفئات الأكثر صعوبة:",
        "progress_over_time": "التقدم بمرور الوقت:",
        "daily_progress": "التقدم اليومي:",
        "weekly_progress": "التقدم الأسبوعي:",
        "monthly_progress": "التقدم الشهري:",
        "learning_trends": "اتجاهات التعلم:",
        "category_performance": "أداء الفئة:",
        "word_performance": "أداء الكلمة:",
        "sentence_performance": "أداء الجملة:",
        "exam_performance": "أداء الاختبار:",
        "memorize_performance": "أداء الحفظ:",
        "flashcards_performance": "أداء البطاقات:",
        "overall_performance": "الأداء العام:",
        "performance_comparison": "مقارنة الأداء:",
        "profile_comparison": "مقارنة الملف الشخصي:",
        "category_comparison": "مقارنة الفئة:",
        "word_comparison": "مقارنة الكلمة:",
        "sentence_comparison": "مقارنة الجملة:",
        "exam_comparison": "مقارنة الاختبار:",
        "memorize_comparison": "مقارنة الحفظ:",
        "flashcards_comparison": "مقارنة البطاقات:",
        "time_comparison": "مقارنة الوقت:",
        "success_rate_comparison": "مقارنة معدل النجاح:",
        "difficulty_comparison": "مقارنة الصعوبة:",
        "progress_comparison": "مقارنة التقدم:",
        "trend_comparison": "مقارنة الاتجاه:",
        "performance_trend": "اتجاه الأداء:",
        "learning_trend": "اتجاه التعلم:",
        "difficulty_trend": "اتجاه الصعوبة:",
        "progress_trend": "اتجاه التقدم:",
        "time_trend": "اتجاه الوقت:",
        "success_rate_trend": "اتجاه معدل النجاح:",
        "category_trend": "اتجاه الفئة:",
        "word_trend": "اتجاه الكلمة:",
        "sentence_trend": "اتجاه الجملة:",
        "exam_trend": "اتجاه الاختبار:",
        "memorize_trend": "اتجاه الحفظ:",
        "flashcards_trend": "اتجاه البطاقات:",
        "overall_trend": "الاتجاه العام:",
        "profile_trend": "اتجاه الملف الشخصي:",
        "comparison_trend": "اتجاه المقارنة:",
        "performance_analysis": "تحليل الأداء:",
        "learning_analysis": "تحليل التعلم:",
        "difficulty_analysis": "تحليل الصعوبة:",
        "progress_analysis": "تحليل التقدم:",
        "time_analysis": "تحليل الوقت:",
        "success_rate_analysis": "تحليل معدل النجاح:",
        "category_analysis": "تحليل الفئة:",
        "word_analysis": "تحليل الكلمة:",
        "sentence_analysis": "تحليل الجملة:",
        "exam_analysis": "تحليل الاختبار:",
        "memorize_analysis": "تحليل الحفظ:",
        "flashcards_analysis": "تحليل البطاقات:",
        "overall_analysis": "التحليل العام:",
        "profile_analysis": "تحليل الملف الشخصي:",
        "comparison_analysis": "تحليل المقارنة:",
        "trend_analysis": "تحليل الاتجاه:",
        "performance_report": "تقرير الأداء:",
        "learning_report": "تقرير التعلم:",
        "difficulty_report": "تقرير الصعوبة:",
        "progress_report": "تقرير التقدم:",
        "time_report": "تقرير الوقت:",
        "success_rate_report": "تقرير معدل النجاح:",
        "category_report": "تقرير الفئة:",
        "word_report": "تقرير الكلمة:",
        "sentence_report": "تقرير الجملة:",
        "exam_report": "تقرير الاختبار:",
        "memorize_report": "تقرير الحفظ:",
        "flashcards_report": "تقرير البطاقات:",
        "overall_report": "التقرير العام:",
        "profile_report": "تقرير الملف الشخصي:",
        "comparison_report": "تقرير المقارنة:",
        "trend_report": "تقرير الاتجاه:",
        "export_stats": "تصدير الإحصائيات",
        "import_stats": "استيراد الإحصائيات",
        "reset_stats": "إعادة تعيين الإحصائيات",
        "stats_exported": "تم تصدير الإحصائيات بنجاح.",
        "stats_imported": "تم استيراد الإحصائيات بنجاح.",
        "stats_reset": "تم إعادة تعيين الإحصائيات بنجاح.",
        "export_error": "حدث خطأ أثناء تصدير الإحصائيات.",
        "import_error": "حدث خطأ أثناء استيراد الإحصائيات.",
        "reset_error": "حدث خطأ أثناء إعادة تعيين الإحصائيات.",
        "select_export_file": "اختر ملف التصدير",
        "select_import_file": "اختر ملف الاستيراد",
        "confirm_reset": "هل أنت متأكد من أنك تريد إعادة تعيين الإحصائيات؟",
        "stats_file": "ملف الإحصائيات",
        "json_files": "ملفات JSON",
        "csv_files": "ملفات CSV",
        "all_files": "جميع الملفات",
        "no_data_to_export": "لا توجد بيانات للتصدير.",
        "invalid_import_file": "ملف استيراد غير صالح.",
        "import_success": "تم الاستيراد بنجاح.",
        "export_success": "تم التصدير بنجاح.",
        "reset_success": "تم إعادة التعيين بنجاح.",
        "operation_failed": "فشلت العملية.",
        "try_again": "الرجاء المحاولة مرة أخرى.",
        "contact_support": "اتصل بفريق الدعم.",
        "error_occurred": "حدث خطأ.",
        "unknown_error": "خطأ غير معروف.",
        "file_not_found": "الملف غير موجود.",
        "permission_denied": "تم رفض الإذن.",
        "disk_full": "القرص ممتلئ.",
        "network_error": "خطأ في الشبكة.",
        "server_error": "خطأ في الخادم.",
        "timeout": "انتهت المهلة.",
        "invalid_data": "بيانات غير صالحة.",
        "data_corrupted": "البيانات تالفة.",
        "operation_canceled": "تم إلغاء العملية.",
        "operation_completed": "اكتملت العملية.",
        "operation_in_progress": "العملية قيد التقدم.",
        "please_wait": "يرجى الانتظار.",
        "processing": "جاري المعالجة...",
        "loading": "جاري التحميل...",
        "saving": "جاري الحفظ...",
        "deleting": "جاري الحذف...",
        "updating": "جاري التحديث...",
        "searching": "جاري البحث...",
        "filtering": "جاري التصفية...",
        "sorting": "جاري الفرز...",
        "exporting": "جاري التصدير...",
        "importing": "جاري الاستيراد...",
        "resetting": "جاري إعادة التعيين...",
        "analyzing": "جاري التحليل...",
        "generating": "جاري الإنشاء...",
        "displaying": "جاري العرض...",
        "refreshing": "جاري التحديث...",
        "synchronizing": "جاري المزامنة...",
        "backing_up": "جاري النسخ الاحتياطي...",
        "restoring": "جاري الاستعادة...",
        "optimizing": "جاري التحسين...",
        "validating": "جاري التحقق...",
        "verifying": "جاري التحقق...",
        "checking": "جاري التحقق...",
        "testing": "جاري الاختبار...",
        "debugging": "جاري تصحيح الأخطاء...",
        "fixing": "جاري الإصلاح...",
        "repairing": "جاري الإصلاح...",
        "recovering": "جاري الاسترداد...",
        "cleaning": "جاري التنظيف...",
        "organizing": "جاري التنظيم...",
        "categorizing": "جاري التصنيف...",
        "tagging": "جاري وضع العلامات...",
        "labeling": "جاري وضع العلامات...",
        "grouping": "جاري التجميع...",
        "sorting_by_name": "جاري الفرز حسب الاسم...",
        "sorting_by_date": "جاري الفرز حسب التاريخ...",
        "sorting_by_size": "جاري الفرز حسب الحجم...",
        "sorting_by_type": "جاري الفرز حسب النوع...",
        "sorting_by_category": "جاري الفرز حسب الفئة...",
        "sorting_by_difficulty": "جاري الفرز حسب الصعوبة...",
        "sorting_by_progress": "جاري الفرز حسب التقدم...",
        "sorting_by_performance": "جاري الفرز حسب الأداء...",
        "sorting_by_time": "جاري الفرز حسب الوقت...",
        "sorting_by_success_rate": "جاري الفرز حسب معدل النجاح...",
        "sorting_by_frequency": "جاري الفرز حسب التكرار...",
        "sorting_by_relevance": "جاري الفرز حسب الصلة...",
        "sorting_by_priority": "جاري الفرز حسب الأولوية...",
        "sorting_by_status": "جاري الفرز حسب الحالة...",
        "sorting_by_owner": "جاري الفرز حسب المالك...",
        "sorting_by_location": "جاري الفرز حسب الموقع...",
        "sorting_by_rating": "جاري الفرز حسب التقييم...",
        "sorting_by_views": "جاري الفرز حسب المشاهدات...",
        "sorting_by_downloads": "جاري الفرز حسب التنزيلات...",
        "sorting_by_likes": "جاري الفرز حسب الإعجابات...",
        "sorting_by_dislikes": "جاري الفرز حسب عدم الإعجابات...",
        "sorting_by_comments": "جاري الفرز حسب التعليقات...",
        "sorting_by_shares": "جاري الفرز حسب المشاركات...",
        "sorting_by_followers": "جاري الفرز حسب المتابعين...",
        "sorting_by_following": "جاري الفرز حسب المتابعين...",
        "sorting_by_friends": "جاري الفرز حسب الأصدقاء...",
        "sorting_by_family": "جاري الفرز حسب العائلة...",
        "sorting_by_colleagues": "جاري الفرز حسب الزملاء...",
        "sorting_by_classmates": "جاري الفرز حسب زملاء الفصل...",
        "sorting_by_teammates": "جاري الفرز حسب زملاء الفريق...",
        "sorting_by_partners": "جاري الفرز حسب الشركاء...",
        "sorting_by_clients": "جاري الفرز حسب العملاء...",
        "sorting_by_customers": "جاري الفرز حسب العملاء...",
        "sorting_by_users": "جاري الفرز حسب المستخدمين...",
        "sorting_by_members": "جاري الفرز حسب الأعضاء...",
        "sorting_by_subscribers": "جاري الفرز حسب المشتركين...",
        "sorting_by_visitors": "جاري الفرز حسب الزوار...",
        "sorting_by_guests": "جاري الفرز حسب الضيوف...",
        "sorting_by_attendees": "جاري الفرز حسب الحاضرين...",
        "sorting_by_participants": "جاري الفرز حسب المشاركين...",
        "sorting_by_volunteers": "جاري الفرز حسب المتطوعين...",
        "sorting_by_employees": "جاري الفرز حسب الموظفين...",
        "sorting_by_employers": "جاري الفرز حسب أصحاب العمل...",
        "sorting_by_applicants": "جاري الفرز حسب المتقدمين...",
        "sorting_by_candidates": "جاري الفرز حسب المرشحين...",
        "sorting_by_interviewees": "جاري الفرز حسب المقابلين...",
        "sorting_by_hires": "جاري الفرز حسب الموظفين الجدد...",
        "sorting_by_fires": "جاري الفرز حسب المفصولين...",
        "sorting_by_resignations": "جاري الفرز حسب الاستقالات...",
        "sorting_by_retirements": "جاري الفرز حسب التقاعد...",
        "sorting_by_promotions": "جاري الفرز حسب الترقيات...",
        "sorting_by_demotions": "جاري الفرز حسب خفض الرتبة...",
        "sorting_by_transfers": "جاري الفرز حسب النقل...",
        "sorting_by_relocations": "جاري الفرز حسب إعادة التوطين...",
        "sorting_by_travels": "جاري الفرز حسب السفر...",
        "sorting_by_trips": "جاري الفرز حسب الرحلات...",
        "sorting_by_vacations": "جاري الفرز حسب الإجازات...",
        "sorting_by_holidays": "جاري الفرز حسب العطلات...",
        "sorting_by_weekends": "جاري الفرز حسب عطلة نهاية الأسبوع...",
        "sorting_by_weekdays": "جاري الفرز حسب أيام الأسبوع...",
        "sorting_by_mornings": "جاري الفرز حسب الصباح...",
        "sorting_by_afternoons": "جاري الفرز حسب بعد الظهر...",
        "sorting_by_evenings": "جاري الفرز حسب المساء...",
        "sorting_by_nights": "جاري الفرز حسب الليل...",
        "sorting_by_midnights": "جاري الفرز حسب منتصف الليل...",
        "sorting_by_dawns": "جاري الفرز حسب الفجر...",
        "sorting_by_noons": "جاري الفرز حسب الظهر...",
        "sorting_by_dusks": "جاري الفرز حسب الغسق...",
        "sorting_by_dawns": "جاري الفرز حسب الفجر...",
        "sorting_by_sunrises": "جاري الفرز حسب شروق الشمس...",
        "sorting_by_sunsets": "جاري الفرز حسب غروب الشمس...",
        "sorting_by_twilights": "جاري الفرز حسب الشفق...",
        "sorting_by_dusks": "جاري الفرز حسب الغسق...",
        "sorting_by_nightfalls": "جاري الفرز حسب سقوط الليل...",
        "sorting_by_midnights": "جاري الفرز حسب منتصف الليل...",
        "sorting_by_small_hours": "جاري الفرز حسب الساعات الصغيرة...",
        "sorting_by_early_hours": "جاري الفرز حسب الساعات المبكرة...",
        "sorting_by_late_hours": "جاري الفرز حسب الساعات المتأخرة...",
        "sorting_by_rush_hours": "جاري الفرز حسب ساعات الذروة...",
        "sorting_by_peak_hours": "جاري الفرز حسب ساعات الذروة...",
        "sorting_by_off_peak_hours": "جاري الفرز حسب ساعات غير الذروة...",
        "sorting_by_business_hours": "جاري الفرز حسب ساعات العمل...",
        "sorting_by_office_hours": "جاري الفرز حسب ساعات المكتب...",
        "sorting_by_working_hours": "جاري الفرز حسب ساعات العمل...",
        "sorting_by_leisure_hours": "جاري الفرز حسب ساعات الفراغ...",
        "sorting_by_free_time": "جاري الفرز حسب وقت الفراغ...",
        "sorting_by_personal_time": "جاري الفرز حسب الوقت الشخصي...",
        "sorting_by_family_time": "جاري الفرز حسب وقت العائلة...",
        "sorting_by_social_time": "جاري الفرز حسب الوقت الاجتماعي...",
        "sorting_by_alone_time": "جاري الفرز حسب الوقت المنفرد...",
        "sorting_by_group_time": "جاري الفرز حسب وقت المجموعة...",
        "sorting_by_team_time": "جاري الفرز حسب وقت الفريق...",
        "sorting_by_pair_time": "جاري الفرز حسب الوقت الثنائي...",
        "sorting_by_solo_time": "جاري الفرز حسب الوقت المنفرد...",
        "sorting_by_duo_time": "جاري الفرز حسب الوقت الثنائي...",
        "sorting_by_trio_time": "جاري الفرز حسب الوقت الثلاثي...",
        "sorting_by_quartet_time": "جاري الفرز حسب الوقت الرباعي...",
        "sorting_by_quintet_time": "جاري الفرز حسب الوقت الخماسي...",
        "sorting_by_sextet_time": "جاري الفرز حسب الوقت السداسي...",
        "sorting_by_septet_time": "جاري الفرز حسب الوقت السباعي...",
        "sorting_by_octet_time": "جاري الفرز حسب الوقت الثماني...",
        "sorting_by_nonet_time": "جاري الفرز حسب الوقت التساعي...",
        "sorting_by_dectet_time": "جاري الفرز حسب الوقت العشري...",
        "sorting_by_large_group_time": "جاري الفرز حسب وقت المجموعة الكبيرة...",
        "sorting_by_small_group_time": "جاري الفرز حسب وقت المجموعة الصغيرة...",
        "sorting_by_medium_group_time": "جاري الفرز حسب وقت المجموعة المتوسطة...",
        "sorting_by_very_large_group_time": "جاري الفرز حسب وقت المجموعة الكبيرة جدًا...",
        "sorting_by_very_small_group_time": "جاري الفرز حسب وقت المجموعة الصغيرة جدًا...",
        "sorting_by_huge_group_time": "جاري الفرز حسب وقت المجموعة الضخمة...",
        "sorting_by_tiny_group_time": "جاري الفرز حسب وقت المجموعة الصغيرة جدًا...",
        "sorting_by_massive_group_time": "جاري الفرز حسب وقت المجموعة الضخمة...",
        "sorting_by_miniscule_group_time": "جاري الفرز حسب وقت المجموعة الصغيرة جدًا...",
        "sorting_by_gigantic_group_time": "جاري الفرز حسب وقت المجموعة الضخمة جدًا...",
        "sorting_by_microscopic_group_time": "جاري الفرز حسب وقت المجموعة المجهرية...",
        "sorting_by_astronomical_group_time": "جاري الفرز حسب وقت المجموعة الفلكية...",
        "sorting_by_infinite_group_time": "جاري الفرز حسب وقت المجموعة اللانهائية...",
        "sorting_by_infinitesimal_group_time": "جاري الفرز حسب وقت المجموعة المتناهية الصغر...",
        "sorting_by_immense_group_time": "جاري الفرز حسب وقت المجموعة الهائلة...",
        "sorting_by_minuscule_group_time": "جاري الفرز حسب وقت المجموعة الصغيرة جدًا...",
        "sorting_by_colossal_group_time": "جاري الفرز حسب وقت المجموعة الضخمة..."
    },
    "ru": {
        "app_title": "Платформа для изучения арабского языка",
        "data_entry": "Ввод данных",
        "practice": "Практика слов",
        "memorize": "Запоминание слов",
        "flashcards": "Карточки",
        "sentence_practice": "Практика предложений",
        "exam_mode": "Экзаменационный режим",
        "management": "Управление",
        "statistics": "Статистика",
        "backup": "Резервное копирование",
        "settings": "Настройки",
        "back": "← Назад",
        "add_single_word": "Добавить одно слово",
        "add_bulk_words": "Добавить несколько слов",
        "add_sentence": "Добавить предложение",
        "turkish_word": "Турецкое слово:",
        "arabic_word": "Арабское слово:",
        "category": "Категория:",
        "new_category": "Новая категория (необязательно):",
        "difficulty": "Уровень сложности (1-5):",
        "notes": "Заметки (необязательно):",
        "select_image": "Выбрать изображение:",
        "browse": "Обзор",
        "save": "Сохранить",
        "turkish_sentence": "Турецкое предложение:",
        "arabic_sentence": "Арабское предложение:",
        "word_practice": "Практика слов",
        "start": "Начать",
        "question": "Вопрос",
        "correct": "Правильно",
        "wrong": "Неправильно",
        "next": "Следующий",
        "select_category": "Выберите категорию и нажмите 'Начать' для начала",
        "light_theme": "Светлая тема",
        "dark_theme": "Темная тема",
        "blue_theme": "Голубая тема",
        "green_theme": "Зеленая тема",
        "language": "Язык:",
        "theme": "Тема:",
        "listen_again": "Слушать снова",
        "create_category": "Создать категорию",
        "category_name": "Название категории:",
        "slayt_mode": "Режим слайдов",
        "manuel_mode": "Ручной режим",
        "transition_time": "Время перехода (секунды):",
        "delete_category": "Удалить категорию",
        "edit_word": "Редактировать слово",
        "edit_sentence": "Редактировать предложение",
        "pause": "Пауза",
        "resume": "Продолжить",
        "finish": "Завершить",
        "previous": "Предыдущий",
        "profile_management": "Управление профилем",
        "add_profile": "Добавить профиль",
        "delete_profile": "Удалить профиль",
        "select_profile": "Выбрать профиль:",
        "profile_name": "Имя профиля:",
        "current_profile": "Текущий профиль:",
        "no_profiles": "Профили не найдены",
        "confirm_delete": "Вы уверены, что хотите удалить?",
        "category_not_empty": "Эта категория не пуста и не может быть удалена.",
        "category_deleted": "Категория успешно удалена.",
        "word_updated": "Слово успешно обновлено.",
        "sentence_updated": "Предложение успешно обновлено.",
        "file_permission_error": "Ошибка разрешения файла: Убедитесь, что файл не используется другим приложением.",
        "word_practice_instruction": "Прослушайте звуковое слово и выберите то, что вы считаете правильным.",
        "show_answer": "Показать ответ",
        "practice_completed": "Практика завершена!",
        "total_questions": "Всего вопросов:",
        "correct_answers": "Правильные ответы:",
        "wrong_answers": "Неправильные ответы:",
        "success_rate": "Успешность:",
        "no_words_found": "В этой категории слова не найдены!",
        "no_sentences_found": "В этой категории предложения не найдены!",
        "memorize_completed": "Запоминание завершено!",
        "total_words": "Всего слов:",
        "flashcards_completed": "Карточки завершены!",
        "total_cards": "Всего карточек:",
        "exam_completed": "Экзамен завершен!",
        "total_exam_questions": "Всего вопросов:",
        "correct_exam_answers": "Правильные ответы:",
        "wrong_exam_answers": "Неправильные ответы:",
        "exam_time": "Время экзамена:",
        "exam_success_rate": "Успешность экзамена:",
        "daily_stats": "Ежедневная статистика",
        "weekly_stats": "Еженедельная статистика",
        "category_stats": "Статистика категорий",
        "no_stats_available": "Нет доступной статистики для отображения.",
        "general_stats": "Общая статистика",
        "profile": "Профиль:",
        "level": "Уровень:",
        "experience": "Опыт:",
        "total_time": "Общее время:",
        "words_learned": "Изученные слова:",
        "sentences_learned": "Изученные предложения:",
        "exam_results": "Результаты экзаменов:",
        "last_exams": "Последние экзамены:",
        "exam_type": "Тип экзамена:",
        "exam_score": "Балл экзамена:",
        "exam_date": "Дата экзамена:",
        "word_practice_stats": "Статистика практики слов",
        "sentence_practice_stats": "Статистика практики предложений",
        "exam_stats": "Статистика экзаменов",
        "memorize_stats": "Статистика запоминания",
        "flashcards_stats": "Статистика карточек",
        "total_practice_time": "Общее время практики:",
        "average_success_rate": "Средняя успешность:",
        "most_difficult_words": "Самые сложные слова:",
        "most_difficult_categories": "Самые сложные категории:",
        "progress_over_time": "Прогресс во времени:",
        "daily_progress": "Ежедневный прогресс:",
        "weekly_progress": "Еженедельный прогресс:",
        "monthly_progress": "Ежемесячный прогресс:",
        "learning_trends": "Тенденции обучения:",
        "category_performance": "Производительность категории:",
        "word_performance": "Производительность слова:",
        "sentence_performance": "Производительность предложения:",
        "exam_performance": "Производительность экзамена:",
        "memorize_performance": "Производительность запоминания:",
        "flashcards_performance": "Производительность карточек:",
        "overall_performance": "Общая производительность:",
        "performance_comparison": "Сравнение производительности:",
        "profile_comparison": "Сравнение профилей:",
        "category_comparison": "Сравнение категорий:",
        "word_comparison": "Сравнение слов:",
        "sentence_comparison": "Сравнение предложений:",
        "exam_comparison": "Сравнение экзаменов:",
        "memorize_comparison": "Сравнение запоминания:",
        "flashcards_comparison": "Сравнение карточек:",
        "time_comparison": "Сравнение времени:",
        "success_rate_comparison": "Сравнение успешности:",
        "difficulty_comparison": "Сравнение сложности:",
        "progress_comparison": "Сравнение прогресса:",
        "trend_comparison": "Сравнение тенденций:",
        "performance_trend": "Тенденция производительности:",
        "learning_trend": "Тенденция обучения:",
        "difficulty_trend": "Тенденция сложности:",
        "progress_trend": "Тенденция прогресса:",
        "time_trend": "Тенденция времени:",
        "success_rate_trend": "Тенденция успешности:",
        "category_trend": "Тенденция категории:",
        "word_trend": "Тенденция слова:",
        "sentence_trend": "Тенденция предложения:",
        "exam_trend": "Тенденция экзамена:",
        "memorize_trend": "Тенденция запоминания:",
        "flashcards_trend": "Тенденция карточек:",
        "overall_trend": "Общая тенденция:",
        "profile_trend": "Тенденция профиля:",
        "comparison_trend": "Тенденция сравнения:",
        "performance_analysis": "Анализ производительности:",
        "learning_analysis": "Анализ обучения:",
        "difficulty_analysis": "Анализ сложности:",
        "progress_analysis": "Анализ прогресса:",
        "time_analysis": "Анализ времени:",
        "success_rate_analysis": "Анализ успешности:",
        "category_analysis": "Анализ категории:",
        "word_analysis": "Анализ слова:",
        "sentence_analysis": "Анализ предложения:",
        "exam_analysis": "Анализ экзамена:",
        "memorize_analysis": "Анализ запоминания:",
        "flashcards_analysis": "Анализ карточек:",
        "overall_analysis": "Общий анализ:",
        "profile_analysis": "Анализ профиля:",
        "comparison_analysis": "Анализ сравнения:",
        "trend_analysis": "Анализ тенденций:",
        "performance_report": "Отчет о производительности:",
        "learning_report": "Отчет об обучении:",
        "difficulty_report": "Отчет о сложности:",
        "progress_report": "Отчет о прогрессе:",
        "time_report": "Отчет о времени:",
        "success_rate_report": "Отчет об успешности:",
        "category_report": "Отчет о категории:",
        "word_report": "Отчет о слове:",
        "sentence_report": "Отчет о предложении:",
        "exam_report": "Отчет об экзамене:",
        "memorize_report": "Отчет о запоминании:",
        "flashcards_report": "Отчет о карточках:",
        "overall_report": "Общий отчет:",
        "profile_report": "Отчет о профиле:",
        "comparison_report": "Отчет о сравнении:",
        "trend_report": "Отчет о тенденциях:",
        "export_stats": "Экспорт статистики",
        "import_stats": "Импорт статистики",
        "reset_stats": "Сброс статистики",
        "stats_exported": "Статистика успешно экспортирована.",
        "stats_imported": "Статистика успешно импортирована.",
        "stats_reset": "Статистика успешно сброшена.",
        "export_error": "Ошибка при экспорте статистики.",
        "import_error": "Ошибка при импорте статистики.",
        "reset_error": "Ошибка при сбросе статистики.",
        "select_export_file": "Выберите файл для экспорта",
        "select_import_file": "Выберите файл для импорта",
        "confirm_reset": "Вы уверены, что хотите сбросить статистику?",
        "stats_file": "Файл статистики",
        "json_files": "Файлы JSON",
        "csv_files": "Файлы CSV",
        "all_files": "Все файлы",
        "no_data_to_export": "Нет данных для экспорта.",
        "invalid_import_file": "Недействительный файл для импорта.",
        "import_success": "Импорт успешен.",
        "export_success": "Экспорт успешен.",
        "reset_success": "Сброс успешен.",
        "operation_failed": "Операция не удалась.",
        "try_again": "Пожалуйста, попробуйте еще раз.",
        "contact_support": "Свяжитесь с командой поддержки.",
        "error_occurred": "Произошла ошибка.",
        "unknown_error": "Неизвестная ошибка.",
        "file_not_found": "Файл не найден.",
        "permission_denied": "В доступе отказано.",
        "disk_full": "Диск заполнен.",
        "network_error": "Ошибка сети.",
        "server_error": "Ошибка сервера.",
        "timeout": "Тайм-аут.",
        "invalid_data": "Недействительные данные.",
        "data_corrupted": "Данные повреждены.",
        "operation_canceled": "Операция отменена.",
        "operation_completed": "Операция завершена.",
        "operation_in_progress": "Операция в процессе.",
        "please_wait": "Пожалуйста, подождите.",
        "processing": "Обработка...",
        "loading": "Загрузка...",
        "saving": "Сохранение...",
        "deleting": "Удаление...",
        "updating": "Обновление...",
        "searching": "Поиск...",
        "filtering": "Фильтрация...",
        "sorting": "Сортировка...",
        "exporting": "Экспорт...",
        "importing": "Импорт...",
        "resetting": "Сброс...",
        "analyzing": "Анализ...",
        "generating": "Генерация...",
        "displaying": "Отображение...",
        "refreshing": "Обновление...",
        "synchronizing": "Синхронизация...",
        "backing_up": "Резервное копирование...",
        "restoring": "Восстановление...",
        "optimizing": "Оптимизация...",
        "validating": "Проверка...",
        "verifying": "Проверка...",
        "checking": "Проверка...",
        "testing": "Тестирование...",
        "debugging": "Отладка...",
        "fixing": "Исправление...",
        "repairing": "Восстановление...",
        "recovering": "Восстановление...",
        "cleaning": "Очистка...",
        "organizing": "Организация...",
        "categorizing": "Категоризация...",
        "tagging": "Тегирование...",
        "labeling": "Маркировка...",
        "grouping": "Группировка...",
        "sorting_by_name": "Сортировка по имени...",
        "sorting_by_date": "Сортировка по дате...",
        "sorting_by_size": "Сортировка по размеру...",
        "sorting_by_type": "Сортировка по типу...",
        "sorting_by_category": "Сортировка по категории...",
        "sorting_by_difficulty": "Сортировка по сложности...",
        "sorting_by_progress": "Сортировка по прогрессу...",
        "sorting_by_performance": "Сортировка по производительности...",
        "sorting_by_time": "Сортировка по времени...",
        "sorting_by_success_rate": "Сортировка по успешности...",
        "sorting_by_frequency": "Сортировка по частоте...",
        "sorting_by_relevance": "Сортировка по релевантности...",
        "sorting_by_priority": "Сортировка по приоритету...",
        "sorting_by_status": "Сортировка по статусу...",
        "sorting_by_owner": "Сортировка по владельцу...",
        "sorting_by_location": "Сортировка по местоположению...",
        "sorting_by_rating": "Сортировка по рейтингу...",
        "sorting_by_views": "Сортировка по просмотрам...",
        "sorting_by_downloads": "Сортировка по загрузкам...",
        "sorting_by_likes": "Сортировка по лайкам...",
        "sorting_by_dislikes": "Сортировка по дизлайкам...",
        "sorting_by_comments": "Сортировка по комментариям...",
        "sorting_by_shares": "Сортировка по поделенным...",
        "sorting_by_followers": "Сортировка по подписчикам...",
        "sorting_by_following": "Сортировка по подпискам...",
        "sorting_by_friends": "Сортировка по друзьям...",
        "sorting_by_family": "Сортировка по семье...",
        "sorting_by_colleagues": "Сортировка по коллегам...",
        "sorting_by_classmates": "Сортировка по одноклассникам...",
        "sorting_by_teammates": "Сортировка по товарищам по команде...",
        "sorting_by_partners": "Сортировка по партнерам...",
        "sorting_by_clients": "Сортировка по клиентам...",
        "sorting_by_customers": "Сортировка по клиентам...",
        "sorting_by_users": "Сортировка по пользователям...",
        "sorting_by_members": "Сортировка по членам...",
        "sorting_by_subscribers": "Сортировка по подписчикам...",
        "sorting_by_visitors": "Сортировка по посетителям...",
        "sorting_by_guests": "Сортировка по гостям...",
        "sorting_by_attendees": "Сортировка по участникам...",
        "sorting_by_participants": "Сортировка по участникам...",
        "sorting_by_volunteers": "Сортировка по добровольцам...",
        "sorting_by_employees": "Сортировка по сотрудникам...",
        "sorting_by_employers": "Сортировка по работодателям...",
        "sorting_by_applicants": "Сортировка по заявителям...",
        "sorting_by_candidates": "Сортировка по кандидатам...",
        "sorting_by_interviewees": "Сортировка по интервьюируемым...",
        "sorting_by_hires": "Сортировка по нанятым...",
        "sorting_by_fires": "Сортировка по уволенным...",
        "sorting_by_resignations": "Сортировка по увольнениям...",
        "sorting_by_retirements": "Сортировка по пенсионерам...",
        "sorting_by_promotions": "Сортировка по повышениям...",
        "sorting_by_demotions": "Сортировка по понижениям...",
        "sorting_by_transfers": "Сортировка по переводам...",
        "sorting_by_relocations": "Сортировка по переездам...",
        "sorting_by_travels": "Сортировка по путешествиям...",
        "sorting_by_trips": "Сортировка по поездкам...",
        "sorting_by_vacations": "Сортировка по отпускам...",
        "sorting_by_holidays": "Сортировка по праздникам...",
        "sorting_by_weekends": "Сортировка по выходным...",
        "sorting_by_weekdays": "Сортировка по будням...",
        "sorting_by_mornings": "Сортировка по утрам...",
        "sorting_by_afternoons": "Сортировка по дням...",
        "sorting_by_evenings": "Сортировка по вечерам...",
        "sorting_by_nights": "Сортировка по ночам...",
        "sorting_by_midnights": "Сортировка по полуночам...",
        "sorting_by_dawns": "Сортировка по рассветам...",
        "sorting_by_noons": "Сортировка по полудням...",
        "sorting_by_dusks": "Сортировка по сумеркам...",
        "sorting_by_dawns": "Сортировка по рассветам...",
        "sorting_by_sunrises": "Сортировка по восходам солнца...",
        "sorting_by_sunsets": "Сортировка по заходам солнца...",
        "sorting_by_twilights": "Сортировка по сумеркам...",
        "sorting_by_dusks": "Сортировка по сумеркам...",
        "sorting_by_nightfalls": "Сортировка по наступлению ночи...",
        "sorting_by_midnights": "Сортировка по полуночам...",
        "sorting_by_small_hours": "Сортировка по ранним часам...",
        "sorting_by_early_hours": "Сортировка по ранним часам...",
        "sorting_by_late_hours": "Сортировка по поздним часам...",
        "sorting_by_rush_hours": "Сортировка по часам пик...",
        "sorting_by_peak_hours": "Сортировка по пиковым часам...",
        "sorting_by_off_peak_hours": "Сортировка по непиковым часам...",
        "sorting_by_business_hours": "Сортировка по рабочим часам...",
        "sorting_by_office_hours": "Сортировка по офисным часам...",
        "sorting_by_working_hours": "Сортировка по рабочим часам...",
        "sorting_by_leisure_hours": "Сортировка по часам досуга...",
        "sorting_by_free_time": "Сортировка по свободному времени...",
        "sorting_by_personal_time": "Сортировка по личному времени...",
        "sorting_by_family_time": "Сортировка по семейному времени...",
        "sorting_by_social_time": "Сортировка по социальному времени...",
        "sorting_by_alone_time": "Сортировка по времени в одиночестве...",
        "sorting_by_group_time": "Сортировка по групповому времени...",
        "sorting_by_team_time": "Сортировка по времени команды...",
        "sorting_by_pair_time": "Сортировка по парному времени...",
        "sorting_by_solo_time": "Сортировка по сольному времени...",
        "sorting_by_duo_time": "Сортировка по дуэтному времени...",
        "sorting_by_trio_time": "Сортировка по трио времени...",
        "sorting_by_quartet_time": "Сортировка по квартетному времени...",
        "sorting_by_quintet_time": "Сортировка по квинтетному времени...",
        "sorting_by_sextet_time": "Сортировка по секстетному времени...",
        "sorting_by_septet_time": "Сортировка по септетному времени...",
        "sorting_by_octet_time": "Сортировка по октетному времени...",
        "sorting_by_nonet_time": "Сортировка по нонетному времени...",
        "sorting_by_dectet_time": "Сортировка по дециметному времени...",
        "sorting_by_large_group_time": "Сортировка по времени большой группы...",
        "sorting_by_small_group_time": "Сортировка по времени маленькой группы...",
        "sorting_by_medium_group_time": "Сортировка по времени средней группы...",
        "sorting_by_very_large_group_time": "Сортировка по времени очень большой группы...",
        "sorting_by_very_small_group_time": "Сортировка по времени очень маленькой группы...",
        "sorting_by_huge_group_time": "Сортировка по времени огромной группы...",
        "sorting_by_tiny_group_time": "Сортировка по времени крошечной группы...",
        "sorting_by_massive_group_time": "Сортировка по времени массивной группы...",
        "sorting_by_miniscule_group_time": "Сортировка по времени мельчайшей группы...",
        "sorting_by_gigantic_group_time": "Сортировка по времени гигантской группы...",
        "sorting_by_microscopic_group_time": "Сортировка по времени микроскопической группы...",
        "sorting_by_astronomical_group_time": "Сортировка по времени астрономической группы...",
        "sorting_by_infinite_group_time": "Сортировка по времени бесконечной группы...",
        "sorting_by_infinitesimal_group_time": "Сортировка по времени бесконечно малой группы...",
        "sorting_by_immense_group_time": "Сортировка по времени огромной группы...",
        "sorting_by_minuscule_group_time": "Сортировка по времени мельчайшей группы...",
        "sorting_by_colossal_group_time": "Сортировка по времени колоссальной группы..."
    }
}

# Tema renkleri
THEMES = {
    "light": {
        "bg": "#f0f0f0",
        "fg": "#000000",
        "title_bg": "#2c3e50",
        "title_fg": "#ffffff",
        "card_bg": "#ffffff",
        "button_bg": "#3498db",
        "button_fg": "#ffffff",
        "button_hover": "#2980b9",
        "correct_bg": "#27ae60",
        "wrong_bg": "#e74c3c",
        "accent": "#3498db"
    },
    "dark": {
        "bg": "#f0f0f0",
        "fg": "#000000",
        "title_bg": "#34495e",
        "title_fg": "#ecf0f1",
        "card_bg": "#34495e",
        "button_bg": "#3498db",
        "button_fg": "#ffffff",
        "button_hover": "#2980b9",
        "correct_bg": "#27ae60",
        "wrong_bg": "#e74c3c",
        "accent": "#3498db"
    },
    "blue": {
        "bg": "#e3f2fd",
        "fg": "#0d47a1",
        "title_bg": "#1976d2",
        "title_fg": "#ffffff",
        "card_bg": "#bbdefb",
        "button_bg": "#2196f3",
        "button_fg": "#ffffff",
        "button_hover": "#0d47a1",
        "correct_bg": "#4caf50",
        "wrong_bg": "#f44336",
        "accent": "#2196f3"
    },
    "green": {
        "bg": "#e8f5e9",
        "fg": "#1b5e20",
        "title_bg": "#388e3c",
        "title_fg": "#ffffff",
        "card_bg": "#c8e6c9",
        "button_bg": "#4caf50",
        "button_fg": "#ffffff",
        "button_hover": "#1b5e20",
        "correct_bg": "#8bc34a",
        "wrong_bg": "#f44336",
        "accent": "#4caf50"
    }
}

class ArabicLearningApp:
    def __init__(self, root):
        self.root = root
        self.current_lang = "tr"  # Varsayılan dil
        self.current_theme = "light"  # Varsayılan tema
        self.current_profile_id = 1  # Varsayılan profil ID
        
        # Dil ve tema ayarlarını yükle
        self.load_settings()
        
        # Mevcut dil ve temaya göre metinleri ve renkleri ayarla
        self.texts = LANGUAGES[self.current_lang]
        self.colors = THEMES[self.current_theme]
        
        self.root.title(self.texts["app_title"])
        self.root.geometry("1000x700")
        self.root.configure(bg=self.colors["bg"])
        
        # Veritabanı bağlantısı
        self.conn = sqlite3.connect('arabic_learning.db')
        self.cursor = self.conn.cursor()
        self.create_tables()
        self.migrate_database()
        
        # Ses çalar için pygame başlatma
        pygame.mixer.init()
        
        # Klasörler
        self.create_folders()
        
        # Global değişkenler
        self.current_page = "main"
        self.words = []
        self.sentences = []
        self.stats = {}
        self.current_quiz = []
        self.current_question_index = 0
        self.quiz_start_time = 0
        self.current_audio_path = None
        self.quiz_answered = False
        self.auto_next_timer = None
        self.current_correct_word = None
        self.current_shown_word = None
        
        # Kelime ezber için değişkenler
        self.memorize_words = []
        self.memorize_index = 0
        self.memorize_mode = "slayt"  # "slayt" veya "manuel"
        self.memorize_timer = None
        self.memorize_auto_next = True
        self.memorize_paused = False
        
        # Flashcards için değişkenler
        self.flashcards_words = []
        self.flashcards_index = 0
        self.flashcards_timer = None
        self.flashcards_difficulty = {}  # Kelime zorluk seviyeleri
        self.flashcards_paused = False
        
        # Cümle çalışması için değişkenler
        self.sentence_practice_words = []
        self.sentence_practice_index = 0
        
        # Ana sayfa
        self.create_main_page()
        
        # Verileri yükle
        self.load_data()
        
    def load_settings(self):
        """Kullanıcı ayarlarını dosyadan yükle"""
        try:
            if os.path.exists('settings.json'):
                with open('settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    self.current_lang = settings.get('language', 'tr')
                    self.current_theme = settings.get('theme', 'light')
                    self.current_profile_id = settings.get('profile_id', 1)
        except Exception as e:
            print(f"Ayarlar yüklenirken hata: {e}")
            
    def save_settings(self):
        """Kullanıcı ayarlarını dosyaya kaydet"""
        try:
            settings = {
                'language': self.current_lang,
                'theme': self.current_theme,
                'profile_id': self.current_profile_id
            }
            with open('settings.json', 'w', encoding='utf-8') as f:
                json.dump(settings, f, ensure_ascii=False, indent=4)
        except Exception as e:
            print(f"Ayarlar kaydedilirken hata: {e}")
            
    def change_language(self, lang_code):
        """Uygulama dilini değiştir"""
        self.current_lang = lang_code
        self.texts = LANGUAGES[self.current_lang]
        self.save_settings()
        
        # Mevcut sayfayı yenile
        if self.current_page == "main":
            self.create_main_page()
        elif self.current_page == "data_entry":
            self.show_data_entry()
        elif self.current_page == "practice":
            self.show_practice()
        elif self.current_page == "management":
            self.show_management()
        elif self.current_page == "settings":
            self.show_settings()
        elif self.current_page == "statistics":
            self.show_stats()
        # Diğer sayfalar için benzer şekilde güncelleme yapılabilir
        
    def change_theme(self, theme_name):
        """Uygulama temasını değiştir"""
        self.current_theme = theme_name
        self.colors = THEMES[self.current_theme]
        self.save_settings()
        
        # Temayı uygula
        self.root.configure(bg=self.colors["bg"])
        
        # Mevcut sayfayı yenile
        if self.current_page == "main":
            self.create_main_page()
        elif self.current_page == "data_entry":
            self.show_data_entry()
        elif self.current_page == "practice":
            self.show_practice()
        elif self.current_page == "management":
            self.show_management()
        elif self.current_page == "settings":
            self.show_settings()
        elif self.current_page == "statistics":
            self.show_stats()
        # Diğer sayfalar için benzer şekilde güncelleme yapılabilir
        
    def change_profile(self, profile_id):
        """Kullanıcı profilini değiştir"""
        self.current_profile_id = profile_id
        self.save_settings()
        
        # Verileri yeniden yükle
        self.load_data()
        
        # Mevcut sayfayı yenile
        if self.current_page == "main":
            self.create_main_page()
        elif self.current_page == "statistics":
            self.show_stats()
        
    def create_tables(self):
        # Kategoriler tablosu
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS categories (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        
        # Words tablosu
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS words (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            turkish TEXT NOT NULL,
            arabic TEXT NOT NULL,
            image_path TEXT,
            audio_path TEXT,
            category_id INTEGER,
            difficulty INTEGER DEFAULT 1,  -- 1-5 arası zorluk seviyesi
            notes TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (category_id) REFERENCES categories (id)
        )
        ''')
        
        # Cümleler tablosu
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS sentences (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            turkish TEXT NOT NULL,
            arabic TEXT NOT NULL,
            audio_path TEXT,
            category_id INTEGER,
            difficulty INTEGER DEFAULT 1,  -- 1-5 arası zorluk seviyesi
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (category_id) REFERENCES categories (id)
        )
        ''')
        
        # Kullanıcı profili tablosu
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_profile (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            level INTEGER DEFAULT 1,
            experience INTEGER DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        
        # Kelime ilerleme tablosu
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS word_progress (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            word_id INTEGER,
            profile_id INTEGER,
            correct_count INTEGER DEFAULT 0,
            wrong_count INTEGER DEFAULT 0,
            last_practiced TIMESTAMP,
            difficulty INTEGER DEFAULT 1,
            FOREIGN KEY (word_id) REFERENCES words (id),
            FOREIGN KEY (profile_id) REFERENCES user_profile (id)
        )
        ''')
        
        # Sınav sonuçları tablosu
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS exam_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            exam_type TEXT,
            category_id INTEGER,
            profile_id INTEGER,
            score INTEGER,
            total_questions INTEGER,
            duration INTEGER,
            date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (category_id) REFERENCES categories (id),
            FOREIGN KEY (profile_id) REFERENCES user_profile (id)
        )
        ''')
        
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS stats (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            profile_id INTEGER,
            correct INTEGER DEFAULT 0,
            wrong INTEGER DEFAULT 0,
            total_time INTEGER DEFAULT 0,
            daily_stats TEXT,
            weekly_stats TEXT,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (profile_id) REFERENCES user_profile (id)
        )
        ''')
        self.conn.commit()
        
    def migrate_database(self):
        self.cursor.execute("PRAGMA table_info(words)")
        columns = [column[1] for column in self.cursor.fetchall()]
        
        # Eski telaffuz sütununu kaldır
        if 'turkish_pronunciation' in columns:
            self.cursor.execute("ALTER TABLE words DROP COLUMN turkish_pronunciation")
            self.conn.commit()
            print("Veritabanı güncellendi: turkish_pronunciation sütunu kaldırıldı")
            
        # Category_id sütununu ekle
        if 'category_id' not in columns:
            self.cursor.execute("ALTER TABLE words ADD COLUMN category_id INTEGER")
            self.conn.commit()
            print("Veritabanı güncellendi: category_id sütunu eklendi")
            
        # Difficulty sütununu ekle
        if 'difficulty' not in columns:
            self.cursor.execute("ALTER TABLE words ADD COLUMN difficulty INTEGER DEFAULT 1")
            self.conn.commit()
            print("Veritabanı güncellendi: difficulty sütunu eklendi")
            
        # Notes sütununu ekle
        if 'notes' not in columns:
            self.cursor.execute("ALTER TABLE words ADD COLUMN notes TEXT")
            self.conn.commit()
            print("Veritabanı güncellendi: notes sütunu eklendi")
            
        # Cümleler tablosunu kontrol et
        self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='sentences'")
        if not self.cursor.fetchone():
            self.create_tables()  # Tabloları yeniden oluştur
            
        # Kullanıcı profili tablosunu kontrol et
        self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='user_profile'")
        if not self.cursor.fetchone():
            self.create_tables()  # Tabloları yeniden oluştur
            
        # Kelime ilerleme tablosunu kontrol et
        self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='word_progress'")
        if not self.cursor.fetchone():
            self.create_tables()  # Tabloları yeniden oluştur
        else:
            # Profile_id sütununu kontrol et
            self.cursor.execute("PRAGMA table_info(word_progress)")
            wp_columns = [column[1] for column in self.cursor.fetchall()]
            if 'profile_id' not in wp_columns:
                self.cursor.execute("ALTER TABLE word_progress ADD COLUMN profile_id INTEGER")
                self.conn.commit()
                print("Veritabanı güncellendi: word_progress tablosuna profile_id sütunu eklendi")
            
        # Sınav sonuçları tablosunu kontrol et
        self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='exam_results'")
        if not self.cursor.fetchone():
            self.create_tables()  # Tabloları yeniden oluştur
        else:
            # Profile_id sütununu kontrol et
            self.cursor.execute("PRAGMA table_info(exam_results)")
            er_columns = [column[1] for column in self.cursor.fetchall()]
            if 'profile_id' not in er_columns:
                self.cursor.execute("ALTER TABLE exam_results ADD COLUMN profile_id INTEGER")
                self.conn.commit()
                print("Veritabanı güncellendi: exam_results tablosuna profile_id sütunu eklendi")
            
        # İstatistikler tablosunu kontrol et
        self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='stats'")
        if not self.cursor.fetchone():
            self.create_tables()  # Tabloları yeniden oluştur
        else:
            # Profile_id sütununu kontrol et
            self.cursor.execute("PRAGMA table_info(stats)")
            stats_columns = [column[1] for column in self.cursor.fetchall()]
            if 'profile_id' not in stats_columns:
                self.cursor.execute("ALTER TABLE stats ADD COLUMN profile_id INTEGER")
                self.conn.commit()
                print("Veritabanı güncellendi: stats tablosuna profile_id sütunu eklendi")
                
        # Varsayılan kullanıcı profilini oluştur
        self.cursor.execute("SELECT COUNT(*) FROM user_profile")
        if self.cursor.fetchone()[0] == 0:
            self.cursor.execute("INSERT INTO user_profile (name, level, experience) VALUES (?, ?, ?)", 
                              ("Öğrenci", 1, 0))
            self.conn.commit()
            print("Varsayılan kullanıcı profili oluşturuldu")
            
        # Mevcut word_progress kayıtlarını güncelle
        self.cursor.execute("SELECT id FROM word_progress WHERE profile_id IS NULL")
        for row in self.cursor.fetchall():
            wp_id = row[0]
            self.cursor.execute("UPDATE word_progress SET profile_id = ? WHERE id = ?", (self.current_profile_id, wp_id))
        self.conn.commit()
        
        # Mevcut exam_results kayıtlarını güncelle
        self.cursor.execute("SELECT id FROM exam_results WHERE profile_id IS NULL")
        for row in self.cursor.fetchall():
            er_id = row[0]
            self.cursor.execute("UPDATE exam_results SET profile_id = ? WHERE id = ?", (self.current_profile_id, er_id))
        self.conn.commit()
        
        # Mevcut stats kayıtlarını güncelle
        self.cursor.execute("SELECT id FROM stats WHERE profile_id IS NULL")
        for row in self.cursor.fetchall():
            stats_id = row[0]
            self.cursor.execute("UPDATE stats SET profile_id = ? WHERE id = ?", (self.current_profile_id, stats_id))
        self.conn.commit()
            
    def create_folders(self):
        if not os.path.exists('resimler'):
            os.makedirs('resimler')
        if not os.path.exists('sesler'):
            os.makedirs('sesler')
        if not os.path.exists('yedekler'):
            os.makedirs('yedekler')
            
    def sanitize_filename(self, filename):
        filename = re.sub(r'[\\/*?:"<>|]', "", filename)
        filename = filename.strip()
        return filename
            
    def create_category(self, category_name):
        try:
            self.cursor.execute("INSERT INTO categories (name) VALUES (?)", (category_name,))
            self.conn.commit()
            return self.cursor.lastrowid
        except sqlite3.IntegrityError:
            # Kategori zaten var
            self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
            return self.cursor.fetchone()[0]
        except Exception as e:
            print(f"Kategori oluşturulurken hata: {e}")
            return None
            
    def delete_category(self, category_id):
        try:
            # Kategoride kelime veya cümle olup olmadığını kontrol et
            self.cursor.execute("SELECT COUNT(*) FROM words WHERE category_id=?", (category_id,))
            word_count = self.cursor.fetchone()[0]
            
            self.cursor.execute("SELECT COUNT(*) FROM sentences WHERE category_id=?", (category_id,))
            sentence_count = self.cursor.fetchone()[0]
            
            if word_count > 0 or sentence_count > 0:
                return False, self.texts["category_not_empty"]
            
            # Kategoriyi sil
            self.cursor.execute("DELETE FROM categories WHERE id=?", (category_id,))
            self.conn.commit()
            return True, self.texts["category_deleted"]
        except Exception as e:
            print(f"Kategori silinirken hata: {e}")
            return False, str(e)
            
    def load_data(self):
        try:
            self.cursor.execute("SELECT * FROM words")
            self.words = self.cursor.fetchall()
            
            self.cursor.execute("SELECT * FROM sentences")
            self.sentences = self.cursor.fetchall()
            
            # Kelime zorluk seviyelerini yükle
            self.flashcards_difficulty = {}
            for word in self.words:
                word_id = word[0]
                self.cursor.execute("SELECT difficulty FROM word_progress WHERE word_id=? AND profile_id=?", 
                                  (word_id, self.current_profile_id))
                result = self.cursor.fetchone()
                if result:
                    self.flashcards_difficulty[word_id] = result[0]
                else:
                    self.flashcards_difficulty[word_id] = 1  # Varsayılan zorluk
                    
        except Exception as e:
            print(f"Kelimeler yüklenirken hata: {e}")
            self.words = []
            self.sentences = []
        
        try:
            self.cursor.execute("SELECT * FROM stats WHERE profile_id=? ORDER BY id DESC LIMIT 1", 
                              (self.current_profile_id,))
            stats_row = self.cursor.fetchone()
            
            if stats_row:
                try:
                    self.stats = {
                        'correct': stats_row[2],
                        'wrong': stats_row[3],
                        'total_time': stats_row[4],
                        'daily': json.loads(stats_row[5]) if stats_row[5] else {},
                        'weekly': json.loads(stats_row[6]) if stats_row[6] else {}
                    }
                except json.JSONDecodeError:
                    print("JSON decode hatası, varsayılan istatistikler kullanılıyor")
                    self.stats = {
                        'correct': 0,
                        'wrong': 0,
                        'total_time': 0,
                        'daily': {},
                        'weekly': {}
                    }
            else:
                self.stats = {
                    'correct': 0,
                    'wrong': 0,
                    'total_time': 0,
                    'daily': {},
                    'weekly': {}
                }
        except Exception as e:
            print(f"İstatistikler yüklenirken hata: {e}")
            self.stats = {
                'correct': 0,
                'wrong': 0,
                'total_time': 0,
                'daily': {},
                'weekly': {}
            }
            
    def save_stats(self):
        try:
            self.cursor.execute('''
            INSERT INTO stats (profile_id, correct, wrong, total_time, daily_stats, weekly_stats)
            VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                self.current_profile_id,
                self.stats['correct'],
                self.stats['wrong'],
                self.stats['total_time'],
                json.dumps(self.stats['daily']),
                json.dumps(self.stats['weekly'])
            ))
            self.conn.commit()
        except Exception as e:
            print(f"İstatistikler kaydedilirken hata: {e}")
        
    def clear_frame(self):
        for widget in self.root.winfo_children():
            widget.destroy()
            
    def create_main_page(self):
        self.clear_frame()
        self.current_page = "main"
        
        # Başlık çerçevesi
        title_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=80)
        title_frame.pack(fill=tk.X)
        title_frame.pack_propagate(False)
        
        # Başlık etiketi
        title_label = tk.Label(
            title_frame, 
            text=self.texts["app_title"], 
            font=("Arial", 20, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(expand=True)
        
        # Kullanıcı profili bilgisi
        self.cursor.execute("SELECT name, level, experience FROM user_profile WHERE id=?", 
                          (self.current_profile_id,))
        user_profile = self.cursor.fetchone()
        if user_profile:
            user_name, user_level, user_exp = user_profile
            profile_label = tk.Label(
                title_frame,
                text=f"{user_name} | Seviye: {user_level} | Deneyim: {user_exp}",
                font=("Arial", 10),
                bg=self.colors["title_bg"],
                fg=self.colors["title_fg"]
            )
            profile_label.pack(side=tk.RIGHT, padx=20)
        
        # Ana menü çerçevesi
        menu_frame = tk.Frame(self.root, bg=self.colors["bg"])
        menu_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Özellikler listesi
        features = [
            (self.texts["data_entry"], "Yeni kelimeler ve cümleler ekleyin", "plus-circle", self.show_data_entry),
            (self.texts["practice"], "Kelimelerle pratik yapın", "pencil-square", self.show_practice),
            (self.texts["memorize"], "Slayt şeklinde ezberleyin", "book", self.show_memorize),
            (self.texts["flashcards"], "Zorluk seviyelerine göre çalışın", "cards", self.show_flashcards),
            (self.texts["sentence_practice"], "Cümlelerle pratik yapın", "chat", self.show_sentence_practice),
            (self.texts["exam_mode"], "Kendinizi test edin", "exam", self.show_exam_mode),
            (self.texts["management"], "Kelimeleri düzenleyin", "gear", self.show_management),
            (self.texts["statistics"], "İlerlemenizi takip edin", "graph-up", self.show_stats),
            (self.texts["backup"], "Verilerinizi yedekleyin", "backup", self.show_backup),
            (self.texts["settings"], "Dil ve tema ayarları", "settings", self.show_settings)
        ]
        
        # Özellik kartlarını oluştur
        for i, (title, desc, icon, command) in enumerate(features):
            card_frame = tk.Frame(menu_frame, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
            card_frame.grid(row=i//3, column=i%3, padx=15, pady=8, sticky="nsew")
            
            menu_frame.grid_rowconfigure(i//3, weight=1)
            menu_frame.grid_columnconfigure(i%3, weight=1)
            
            # İkon (yerine basit bir daire kullanıyoruz)
            icon_label = tk.Label(card_frame, text="●", font=("Arial", 10), bg=self.colors["card_bg"], fg=self.colors["accent"])
            icon_label.pack(pady=2)
            
            # Başlık
            title_label = tk.Label(card_frame, text=title, font=("Arial", 12, "bold"), bg=self.colors["card_bg"], fg=self.colors["fg"])
            title_label.pack()
            
            # Açıklama
            desc_label = tk.Label(card_frame, text=desc, font=("Arial", 9), bg=self.colors["card_bg"], fg="gray")
            desc_label.pack(pady=5)
            
            # Buton
            button = tk.Button(
                card_frame,
                text="Aç",
                command=command,
                bg=self.colors["button_bg"],
                fg=self.colors["button_fg"],
                font=("Arial", 12, "bold"),
                relief=tk.FLAT,
                padx=25,
                pady=12
            )
            button.pack(pady=15)
            
            # Buton hover efektleri
            def on_enter(e, btn=button):
                btn.config(bg=self.colors["button_hover"])
            def on_leave(e, btn=button):
                btn.config(bg=self.colors["button_bg"])
                
            button.bind("<Enter>", on_enter)
            button.bind("<Leave>", on_leave)
            
    def show_settings(self):
        self.clear_frame()
        self.current_page = "settings"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["settings"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Ayarlar çerçevesi
        settings_container = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        settings_container.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Profil yönetimi
        profile_frame = tk.LabelFrame(
            settings_container,
            text=self.texts["profile_management"],
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        profile_frame.pack(fill=tk.X, padx=20, pady=20)
        
        # Mevcut profil
        current_profile_frame = tk.Frame(profile_frame, bg=self.colors["card_bg"])
        current_profile_frame.pack(fill=tk.X, padx=10, pady=10)
        
        tk.Label(
            current_profile_frame,
            text=self.texts["current_profile"],
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=5)
        
        self.cursor.execute("SELECT name FROM user_profile WHERE id=?", (self.current_profile_id,))
        current_profile = self.cursor.fetchone()
        current_profile_name = current_profile[0] if current_profile else self.texts["no_profiles"]
        
        self.current_profile_label = tk.Label(
            current_profile_frame,
            text=current_profile_name,
            font=("Arial", 12, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["accent"]
        )
        self.current_profile_label.pack(side=tk.LEFT, padx=5)
        
        # Profil seçimi
        profile_select_frame = tk.Frame(profile_frame, bg=self.colors["card_bg"])
        profile_select_frame.pack(fill=tk.X, padx=10, pady=10)
        
        tk.Label(
            profile_select_frame,
            text=self.texts["select_profile"],
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=5)
        
        self.profile_var = tk.StringVar()
        self.profile_combobox = ttk.Combobox(
            profile_select_frame,
            textvariable=self.profile_var,
            state="readonly",
            width=20,
            font=("Arial", 12)
        )
        self.profile_combobox.pack(side=tk.LEFT, padx=5)
        self.profile_combobox.bind("<<ComboboxSelected>>", self.on_profile_selected)
        
        # Profil ekleme/silme
        profile_btn_frame = tk.Frame(profile_frame, bg=self.colors["card_bg"])
        profile_btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        add_profile_btn = tk.Button(
            profile_btn_frame,
            text=self.texts["add_profile"],
            command=self.add_profile,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=15,
            pady=5
        )
        add_profile_btn.pack(side=tk.LEFT, padx=5)
        
        delete_profile_btn = tk.Button(
            profile_btn_frame,
            text=self.texts["delete_profile"],
            command=self.delete_profile,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=15,
            pady=5
        )
        delete_profile_btn.pack(side=tk.LEFT, padx=5)
        
        # Dil seçimi
        lang_frame = tk.Frame(settings_container, bg=self.colors["card_bg"])
        lang_frame.pack(fill=tk.X, padx=20, pady=20)
        
        tk.Label(
            lang_frame, 
            text=self.texts["language"], 
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        lang_var = tk.StringVar(value=self.current_lang)
        lang_menu = ttk.Combobox(
            lang_frame, 
            textvariable=lang_var,
            values=["tr", "en", "ar", "ru"],
            state="readonly",
            width=10,
            font=("Arial", 12)
        )
        lang_menu.pack(side=tk.LEFT, padx=10)
        lang_menu.bind("<<ComboboxSelected>>", lambda e: self.change_language(lang_var.get()))
        
        # Dil açıklamaları
        lang_desc_frame = tk.Frame(settings_container, bg=self.colors["card_bg"])
        lang_desc_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            lang_desc_frame,
            text="tr: Türkçe | en: English | ar: العربية | ru: Русский",
            font=("Arial", 10),
            bg=self.colors["card_bg"],
            fg="gray"
        ).pack()
        
        # Tema seçimi
        theme_frame = tk.Frame(settings_container, bg=self.colors["card_bg"])
        theme_frame.pack(fill=tk.X, padx=20, pady=20)
        
        tk.Label(
            theme_frame, 
            text=self.texts["theme"], 
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        theme_var = tk.StringVar(value=self.current_theme)
        theme_menu = ttk.Combobox(
            theme_frame, 
            textvariable=theme_var,
            values=["light", "dark", "blue", "green"],
            state="readonly",
            width=10,
            font=("Arial", 12)
        )
        theme_menu.pack(side=tk.LEFT, padx=10)
        theme_menu.bind("<<ComboboxSelected>>", lambda e: self.change_theme(theme_var.get()))
        
        # Tema önizlemeleri
        preview_frame = tk.Frame(settings_container, bg=self.colors["card_bg"])
        preview_frame.pack(fill=tk.X, padx=20, pady=20)
        
        # Açık tema
        light_frame = tk.Frame(preview_frame, bg="#ffffff", relief=tk.RAISED, bd=2)
        light_frame.pack(side=tk.LEFT, padx=10, pady=10)
        
        tk.Label(
            light_frame,
            text=self.texts["light_theme"],
            font=("Arial", 10),
            bg="#ffffff",
            fg="#000000"
        ).pack(padx=10, pady=10)
        
        # Koyu tema
        dark_frame = tk.Frame(preview_frame, bg="#2c3e50", relief=tk.RAISED, bd=2)
        dark_frame.pack(side=tk.LEFT, padx=10, pady=10)
        
        tk.Label(
            dark_frame,
            text=self.texts["dark_theme"],
            font=("Arial", 10),
            bg="#2c3e50",
            fg="#ecf0f1"
        ).pack(padx=10, pady=10)
        
        # Mavi tema
        blue_frame = tk.Frame(preview_frame, bg="#e3f2fd", relief=tk.RAISED, bd=2)
        blue_frame.pack(side=tk.LEFT, padx=10, pady=10)
        
        tk.Label(
            blue_frame,
            text=self.texts["blue_theme"],
            font=("Arial", 10),
            bg="#e3f2fd",
            fg="#0d47a1"
        ).pack(padx=10, pady=10)
        
        # Yeşil tema
        green_frame = tk.Frame(preview_frame, bg="#e8f5e9", relief=tk.RAISED, bd=2)
        green_frame.pack(side=tk.LEFT, padx=10, pady=10)
        
        tk.Label(
            green_frame,
            text=self.texts["green_theme"],
            font=("Arial", 10),
            bg="#e8f5e9",
            fg="#1b5e20"
        ).pack(padx=10, pady=10)
        
        # Uygula butonu
        apply_btn = tk.Button(
            settings_container,
            text="Uygula",
            command=lambda: self.change_theme(theme_var.get()),
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        apply_btn.pack(pady=20)
        
        # Profil listesini yükle
        self.load_profiles()
        
    def load_profiles(self):
        try:
            self.cursor.execute("SELECT id, name FROM user_profile ORDER BY name")
            profiles = self.cursor.fetchall()
            
            if profiles:
                profile_names = [f"{p[1]} (ID: {p[0]})" for p in profiles]
                self.profile_combobox['values'] = profile_names
                
                # Mevcut profili seç
                for i, (profile_id, _) in enumerate(profiles):
                    if profile_id == self.current_profile_id:
                        self.profile_combobox.current(i)
                        break
            else:
                self.profile_combobox['values'] = [self.texts["no_profiles"]]
                self.profile_combobox.current(0)
        except Exception as e:
            print(f"Profiller yüklenirken hata: {e}")
            
    def on_profile_selected(self, event):
        selected = self.profile_combobox.get()
        if selected and selected != self.texts["no_profiles"]:
            # ID'yi çıkar
            profile_id = int(selected.split("ID: ")[1].split(")")[0])
            self.change_profile(profile_id)
            
    def add_profile(self):
        dialog = tk.Toplevel(self.root)
        dialog.title(self.texts["add_profile"])
        dialog.geometry("300x150")
        dialog.configure(bg=self.colors["bg"])
        dialog.transient(self.root)
        dialog.grab_set()
        
        tk.Label(
            dialog,
            text=self.texts["profile_name"],
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(pady=10)
        
        name_var = tk.StringVar()
        name_entry = tk.Entry(dialog, textvariable=name_var, font=("Arial", 12))
        name_entry.pack(pady=10, padx=20, fill=tk.X)
        name_entry.focus_set()
        
        def save():
            name = name_var.get().strip()
            if name:
                try:
                    self.cursor.execute("INSERT INTO user_profile (name, level, experience) VALUES (?, ?, ?)", 
                                      (name, 1, 0))
                    self.conn.commit()
                    messagebox.showinfo("Başarılı", "Profil başarıyla oluşturuldu!")
                    dialog.destroy()
                    self.load_profiles()
                except Exception as e:
                    messagebox.showerror("Hata", f"Profil oluşturulurken hata: {e}")
            else:
                messagebox.showwarning("Uyarı", "Lütfen profil adını girin!")
                
        save_btn = tk.Button(
            dialog,
            text=self.texts["save"],
            command=save,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        save_btn.pack(pady=10)
        
    def delete_profile(self):
        if self.current_profile_id == 1:
            messagebox.showwarning("Uyarı", "Varsayılan profil silinemez!")
            return
            
        if messagebox.askyesno("Onay", self.texts["confirm_delete"]):
            try:
                # Profili sil
                self.cursor.execute("DELETE FROM user_profile WHERE id=?", (self.current_profile_id,))
                self.conn.commit()
                
                # Varsayılan profile geç
                self.change_profile(1)
                messagebox.showinfo("Başarılı", "Profil başarıyla silindi!")
                self.load_profiles()
            except Exception as e:
                messagebox.showerror("Hata", f"Profil silinirken hata: {e}")
                
    def show_data_entry(self):
        self.clear_frame()
        self.current_page = "data_entry"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["data_entry"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        button_frame = tk.Frame(self.root, bg=self.colors["bg"])
        button_frame.pack(fill=tk.X, padx=20, pady=5)
        
        word_entry_btn = tk.Button(
            button_frame,
            text=self.texts["add_single_word"],
            command=self.show_single_word_entry,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        word_entry_btn.pack(side=tk.LEFT, padx=5)
        
        bulk_word_entry_btn = tk.Button(
            button_frame,
            text=self.texts["add_bulk_words"],
            command=self.show_bulk_word_entry,
            bg="#27ae60",
            fg="white",
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        bulk_word_entry_btn.pack(side=tk.LEFT, padx=5)
        
        sentence_entry_btn = tk.Button(
            button_frame,
            text=self.texts["add_sentence"],
            command=self.show_sentence_entry,
            bg="#9b59b6",
            fg="white",
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        sentence_entry_btn.pack(side=tk.LEFT, padx=5)
        
        create_category_btn = tk.Button(
            button_frame,
            text=self.texts["create_category"],
            command=self.show_create_category,
            bg="#f39c12",
            fg="white",
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        create_category_btn.pack(side=tk.LEFT, padx=5)
        
        delete_category_btn = tk.Button(
            button_frame,
            text=self.texts["delete_category"],
            command=self.show_delete_category,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        delete_category_btn.pack(side=tk.LEFT, padx=5)
        
        self.content_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.content_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        self.show_single_word_entry()
        
    def show_create_category(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        tk.Label(
            self.content_frame, 
            text=self.texts["create_category"], 
            font=("Arial", 16, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        tk.Label(self.content_frame, text=self.texts["category_name"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).pack(pady=5)
        
        self.category_name_var = tk.StringVar()
        category_name_entry = tk.Entry(self.content_frame, textvariable=self.category_name_var, font=("Arial", 12), width=40)
        category_name_entry.pack(pady=5)
        category_name_entry.focus_set()
        
        save_btn = tk.Button(
            self.content_frame,
            text=self.texts["save"],
            command=self.save_category,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        save_btn.pack(pady=20)
        
    def show_delete_category(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        tk.Label(
            self.content_frame, 
            text=self.texts["delete_category"], 
            font=("Arial", 16, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        tk.Label(self.content_frame, text=self.texts["category_name"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).pack(pady=5)
        
        self.delete_category_var = tk.StringVar()
        category_combobox = ttk.Combobox(
            self.content_frame, 
            textvariable=self.delete_category_var,
            font=("Arial", 12),
            width=40
        )
        category_combobox.pack(pady=5)
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT id, name FROM categories ORDER BY name")
            categories = self.cursor.fetchall()
            category_names = [f"{cat[1]} (ID: {cat[0]})" for cat in categories]
            category_combobox['values'] = category_names
            if category_names:
                category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        delete_btn = tk.Button(
            self.content_frame,
            text="Sil",
            command=self.delete_selected_category,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        delete_btn.pack(pady=20)
        
    def delete_selected_category(self):
        selected = self.delete_category_var.get()
        if not selected:
            messagebox.showwarning("Uyarı", "Lütfen bir kategori seçin!")
            return
            
        # ID'yi çıkar
        category_id = int(selected.split("ID: ")[1].split(")")[0])
        
        success, message = self.delete_category(category_id)
        if success:
            messagebox.showinfo("Başarılı", message)
            # Kategori listesini güncelle
            self.show_delete_category()
        else:
            messagebox.showwarning("Hata", message)
        
    def save_category(self):
        category_name = self.category_name_var.get().strip()
        
        if not category_name:
            messagebox.showwarning("Uyarı", "Lütfen kategori adını girin!")
            return
            
        try:
            # Kategoriyi ekle
            self.cursor.execute("INSERT INTO categories (name) VALUES (?)", (category_name,))
            self.conn.commit()
            
            messagebox.showinfo("Başarılı", "Kategori başarıyla oluşturuldu!")
            
            # Alanı temizle
            self.category_name_var.set("")
            
        except sqlite3.IntegrityError:
            messagebox.showwarning("Uyarı", "Bu kategori zaten mevcut!")
        except Exception as e:
            messagebox.showerror("Hata", f"Kategori oluşturulurken hata: {e}")
        
    def show_single_word_entry(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        # Ana çerçeve
        main_frame = tk.Frame(self.content_frame, bg=self.colors["card_bg"])
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Sol çerçeve - form alanları
        left_frame = tk.Frame(main_frame, bg=self.colors["card_bg"])
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Sağ çerçeve - resim önizlemesi
        right_frame = tk.Frame(main_frame, bg=self.colors["card_bg"], width=200)
        right_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=20)
        right_frame.pack_propagate(False)
        
        # Form alanları
        tk.Label(left_frame, text=self.texts["turkish_word"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=0, column=0, sticky="w", padx=20, pady=10)
        self.turkish_entry = tk.Entry(left_frame, font=("Arial", 12), width=40)
        self.turkish_entry.grid(row=0, column=1, padx=20, pady=10)
        
        tk.Label(left_frame, text=self.texts["arabic_word"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=1, column=0, sticky="w", padx=20, pady=10)
        self.arabic_entry = tk.Entry(left_frame, font=("Arial", 12), width=40)
        self.arabic_entry.grid(row=1, column=1, padx=20, pady=10)
        
        # Kategori seçimi
        tk.Label(left_frame, text=self.texts["category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=2, column=0, sticky="w", padx=20, pady=10)
        
        self.category_var = tk.StringVar()
        self.category_combobox = ttk.Combobox(left_frame, textvariable=self.category_var, font=("Arial", 10), width=37)
        self.category_combobox.grid(row=2, column=1, padx=20, pady=10, sticky="w")
        
        # Mevcut kategorileri yükle
        self.load_categories()
        
        # Yeni kategori oluşturma
        tk.Label(left_frame, text=self.texts["new_category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=3, column=0, sticky="w", padx=20, pady=10)
        self.new_category_var = tk.StringVar()
        new_category_entry = tk.Entry(left_frame, textvariable=self.new_category_var, font=("Arial", 12), width=40)
        new_category_entry.grid(row=3, column=1, padx=20, pady=10)
        
        # Zorluk seviyesi
        tk.Label(left_frame, text=self.texts["difficulty"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=4, column=0, sticky="w", padx=20, pady=10)
        self.difficulty_var = tk.IntVar(value=1)
        difficulty_frame = tk.Frame(left_frame, bg=self.colors["card_bg"])
        difficulty_frame.grid(row=4, column=1, padx=20, pady=10, sticky="w")
        
        for i in range(1, 6):
            tk.Radiobutton(
                difficulty_frame,
                text=str(i),
                variable=self.difficulty_var,
                value=i,
                bg=self.colors["card_bg"],
                fg=self.colors["fg"]
            ).pack(side=tk.LEFT, padx=5)
        
        # Notlar
        tk.Label(left_frame, text=self.texts["notes"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=5, column=0, sticky="w", padx=20, pady=10)
        self.notes_text = scrolledtext.ScrolledText(left_frame, width=40, height=5, font=("Arial", 10))
        self.notes_text.grid(row=5, column=1, padx=20, pady=10)
        
        # Resim seçimi
        tk.Label(left_frame, text=self.texts["select_image"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=6, column=0, sticky="w", padx=20, pady=10)
        self.image_path_var = tk.StringVar()
        image_frame = tk.Frame(left_frame, bg=self.colors["card_bg"])
        image_frame.grid(row=6, column=1, padx=20, pady=10, sticky="w")
        
        self.image_entry = tk.Entry(image_frame, textvariable=self.image_path_var, font=("Arial", 10), width=30)
        self.image_entry.pack(side=tk.LEFT)
        
        image_btn = tk.Button(
            image_frame,
            text=self.texts["browse"],
            command=self.browse_image,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 10),
            relief=tk.FLAT
        )
        image_btn.pack(side=tk.LEFT, padx=5)
        
        # Ses durumu
        self.audio_status_label = tk.Label(left_frame, text="", font=("Arial", 10), bg=self.colors["card_bg"], fg=self.colors["fg"])
        self.audio_status_label.grid(row=7, column=0, columnspan=2, pady=5)
        
        # Kaydet butonu
        save_btn = tk.Button(
            left_frame,
            text=self.texts["save"],
            command=self.save_word,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        save_btn.grid(row=8, column=0, columnspan=2, pady=20)
        
        # Resim önizlemesi
        tk.Label(right_frame, text="Resim Önizleme", font=("Arial", 12, "bold"), bg=self.colors["card_bg"], fg=self.colors["fg"]).pack(pady=10)
        
        self.image_preview_label = tk.Label(right_frame, bg=self.colors["card_bg"], width=20, height=10)
        self.image_preview_label.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)
        
    def show_sentence_entry(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        tk.Label(self.content_frame, text=self.texts["turkish_sentence"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=0, column=0, sticky="w", padx=20, pady=10)
        self.turkish_sentence_entry = tk.Entry(self.content_frame, font=("Arial", 12), width=40)
        self.turkish_sentence_entry.grid(row=0, column=1, padx=20, pady=10)
        
        tk.Label(self.content_frame, text=self.texts["arabic_sentence"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=1, column=0, sticky="w", padx=20, pady=10)
        self.arabic_sentence_entry = tk.Entry(self.content_frame, font=("Arial", 12), width=40)
        self.arabic_sentence_entry.grid(row=1, column=1, padx=20, pady=10)
        
        # Kategori seçimi
        tk.Label(self.content_frame, text=self.texts["category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=2, column=0, sticky="w", padx=20, pady=10)
        
        self.sentence_category_var = tk.StringVar()
        self.sentence_category_combobox = ttk.Combobox(self.content_frame, textvariable=self.sentence_category_var, font=("Arial", 10), width=37)
        self.sentence_category_combobox.grid(row=2, column=1, padx=20, pady=10, sticky="w")
        
        # Mevcut kategorileri yükle
        self.load_sentence_categories()
        
        # Yeni kategori oluşturma
        tk.Label(self.content_frame, text=self.texts["new_category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=3, column=0, sticky="w", padx=20, pady=10)
        self.new_sentence_category_var = tk.StringVar()
        new_sentence_category_entry = tk.Entry(self.content_frame, textvariable=self.new_sentence_category_var, font=("Arial", 12), width=40)
        new_sentence_category_entry.grid(row=3, column=1, padx=20, pady=10)
        
        # Zorluk seviyesi
        tk.Label(self.content_frame, text=self.texts["difficulty"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=4, column=0, sticky="w", padx=20, pady=10)
        self.sentence_difficulty_var = tk.IntVar(value=1)
        sentence_difficulty_frame = tk.Frame(self.content_frame, bg=self.colors["card_bg"])
        sentence_difficulty_frame.grid(row=4, column=1, padx=20, pady=10, sticky="w")
        
        for i in range(1, 6):
            tk.Radiobutton(
                sentence_difficulty_frame,
                text=str(i),
                variable=self.sentence_difficulty_var,
                value=i,
                bg=self.colors["card_bg"],
                fg=self.colors["fg"]
            ).pack(side=tk.LEFT, padx=5)
        
        self.sentence_audio_status_label = tk.Label(self.content_frame, text="", font=("Arial", 10), bg=self.colors["card_bg"], fg=self.colors["fg"])
        self.sentence_audio_status_label.grid(row=5, column=0, columnspan=2, pady=5)
        
        save_btn = tk.Button(
            self.content_frame,
            text=self.texts["save"],
            command=self.save_sentence,
            bg="#9b59b6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        save_btn.grid(row=6, column=0, columnspan=2, pady=20)
        
    def load_categories(self):
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            self.category_combobox['values'] = categories
            if categories:
                self.category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
    def load_sentence_categories(self):
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            self.sentence_category_combobox['values'] = categories
            if categories:
                self.sentence_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
    def show_bulk_word_entry(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        # Üst kısım - metin alanı
        upper_frame = tk.Frame(self.content_frame, bg=self.colors["card_bg"])
        upper_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        tk.Label(
            upper_frame,
            text=self.texts["add_bulk_words"],
            font=("Arial", 16, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=5)
        
        tk.Label(
            upper_frame,
            text="Format: Türkçe Kelime | Arapça Kelime | Kategori (isteğe bağlı)",
            font=("Arial", 10),
            bg=self.colors["card_bg"],
            fg="gray"
        ).pack(pady=5)
        
        self.bulk_text = scrolledtext.ScrolledText(upper_frame, width=60, height=15, font=("Arial", 11))
        self.bulk_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Alt kısım - butonlar
        bottom_frame = tk.Frame(self.content_frame, bg=self.colors["card_bg"])
        bottom_frame.pack(fill=tk.X, padx=20, pady=10)
        
        save_btn = tk.Button(
            bottom_frame,
            text=self.texts["save"],
            command=self.save_bulk_words,
            bg="#27ae60",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        save_btn.pack(side=tk.RIGHT, padx=5)
        
        clear_btn = tk.Button(
            bottom_frame,
            text="Temizle",
            command=lambda: self.bulk_text.delete(1.0, tk.END),
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        clear_btn.pack(side=tk.RIGHT, padx=5)
        
    def browse_image(self):
        file_path = filedialog.askopenfilename(
            title="Resim Seç",
            filetypes=[("Image files", "*.jpg *.jpeg *.png *.gif *.bmp")]
        )
        
        if file_path:
            self.image_path_var.set(file_path)
            
            # Resmi önizle
            try:
                img = Image.open(file_path)
                img = img.resize((150, 150), Image.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                
                self.image_preview_label.config(image=photo)
                self.image_preview_label.image = photo  # Referansı tut
            except Exception as e:
                print(f"Resim önizlenirken hata: {e}")
                self.image_preview_label.config(image="", text="Resim yüklenemedi")
        
    def save_word(self):
        turkish = self.turkish_entry.get().strip()
        arabic = self.arabic_entry.get().strip()
        category_name = self.category_var.get()
        new_category = self.new_category_var.get().strip()
        difficulty = self.difficulty_var.get()
        notes = self.notes_text.get(1.0, tk.END).strip()
        image_path = self.image_path_var.get()
        
        if not turkish or not arabic:
            messagebox.showwarning("Uyarı", "Lütfen Türkçe ve Arapça kelimeleri girin!")
            return
            
        # Kategori işlemleri
        if new_category:
            category_id = self.create_category(new_category)
        elif category_name:
            self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
            result = self.cursor.fetchone()
            if result:
                category_id = result[0]
            else:
                messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin veya yeni kategori oluşturun!")
                return
        else:
            category_id = None
            
        # Resim işlemleri
        final_image_path = None
        if image_path:
            try:
                # Resim dosyasını kopyala
                image_filename = f"{self.sanitize_filename(turkish)}.jpg"
                final_image_path = os.path.join("resimler", image_filename)
                img = Image.open(image_path)
                if img.mode == "RGBA":
                    img = img.convert("RGB")
                img.save(final_image_path)
            except Exception as e:
                print(f"Resim kaydedilirken hata: {e}")
                messagebox.showwarning("Uyarı", f"Resim kaydedilemedi: {e}")
                
        # Ses dosyası oluştur
        audio_path = None
        try:
            audio_filename = f"{self.sanitize_filename(turkish)}.mp3"
            audio_path = os.path.join("sesler", audio_filename)
            
            # Eğer dosya zaten varsa, üzerine yazmayı dene
            if os.path.exists(audio_path):
                try:
                    os.remove(audio_path)
                except PermissionError:
                    # Dosya kullanımda ise, alternatif bir isim dene
                    base_name = os.path.splitext(audio_filename)[0]
                    audio_filename = f"{base_name}_{int(time.time())}.mp3"
                    audio_path = os.path.join("sesler", audio_filename)
                    
            tts = gTTS(text=arabic, lang='ar')
            tts.save(audio_path)
            
            self.audio_status_label.config(text="Ses dosyası oluşturuldu", fg="green")
        except Exception as e:
            print(f"Ses dosyası oluşturulurken hata: {e}")
            self.audio_status_label.config(text=f"Ses dosyası oluşturulamadı: {e}", fg="red")
            # Ses dosyası oluşturulamasa bile kelimeyi kaydetmeye devam et
            
        try:
            # Kelimeyi veritabanına ekle
            self.cursor.execute('''
            INSERT INTO words (turkish, arabic, image_path, audio_path, category_id, difficulty, notes)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (turkish, arabic, final_image_path, audio_path, category_id, difficulty, notes))
            
            word_id = self.cursor.lastrowid
            
            # Kelime ilerlemesini ekle
            self.cursor.execute('''
            INSERT INTO word_progress (word_id, profile_id, difficulty)
            VALUES (?, ?, ?)
            ''', (word_id, self.current_profile_id, difficulty))
            
            self.conn.commit()
            
            messagebox.showinfo("Başarılı", "Kelime başarıyla eklendi!")
            
            # Formu temizle
            self.turkish_entry.delete(0, tk.END)
            self.arabic_entry.delete(0, tk.END)
            self.new_category_var.set("")
            self.notes_text.delete(1.0, tk.END)
            self.image_path_var.set("")
            self.image_preview_label.config(image="", text="")
            self.audio_status_label.config(text="")
            
            # Verileri yeniden yükle
            self.load_data()
            
        except Exception as e:
            messagebox.showerror("Hata", f"Kelime eklenirken hata: {e}")
            
    def save_sentence(self):
        turkish = self.turkish_sentence_entry.get().strip()
        arabic = self.arabic_sentence_entry.get().strip()
        category_name = self.sentence_category_var.get()
        new_category = self.new_sentence_category_var.get().strip()
        difficulty = self.sentence_difficulty_var.get()
        
        if not turkish or not arabic:
            messagebox.showwarning("Uyarı", "Lütfen Türkçe ve Arapça cümleleri girin!")
            return
            
        # Kategori işlemleri
        if new_category:
            category_id = self.create_category(new_category)
        elif category_name:
            self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
            result = self.cursor.fetchone()
            if result:
                category_id = result[0]
            else:
                messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin veya yeni kategori oluşturun!")
                return
        else:
            category_id = None
            
        # Ses dosyası oluştur
        audio_path = None
        try:
            audio_filename = f"{self.sanitize_filename(turkish[:20])}.mp3"
            audio_path = os.path.join("sesler", audio_filename)
            
            # Eğer dosya zaten varsa, üzerine yazmayı dene
            if os.path.exists(audio_path):
                try:
                    os.remove(audio_path)
                except PermissionError:
                    # Dosya kullanımda ise, alternatif bir isim dene
                    base_name = os.path.splitext(audio_filename)[0]
                    audio_filename = f"{base_name}_{int(time.time())}.mp3"
                    audio_path = os.path.join("sesler", audio_filename)
                    
            tts = gTTS(text=arabic, lang='ar')
            tts.save(audio_path)
            
            self.sentence_audio_status_label.config(text="Ses dosyası oluşturuldu", fg="green")
        except Exception as e:
            print(f"Ses dosyası oluşturulurken hata: {e}")
            self.sentence_audio_status_label.config(text=f"Ses dosyası oluşturulamadı: {e}", fg="red")
            # Ses dosyası oluşturulamasa bile cümleyi kaydetmeye devam et
            
        try:
            # Cümleyi veritabanına ekle
            self.cursor.execute('''
            INSERT INTO sentences (turkish, arabic, audio_path, category_id, difficulty)
            VALUES (?, ?, ?, ?, ?)
            ''', (turkish, arabic, audio_path, category_id, difficulty))
            
            self.conn.commit()
            
            messagebox.showinfo("Başarılı", "Cümle başarıyla eklendi!")
            
            # Formu temizle
            self.turkish_sentence_entry.delete(0, tk.END)
            self.arabic_sentence_entry.delete(0, tk.END)
            self.new_sentence_category_var.set("")
            self.sentence_audio_status_label.config(text="")
            
            # Verileri yeniden yükle
            self.load_data()
            
        except Exception as e:
            messagebox.showerror("Hata", f"Cümle eklenirken hata: {e}")
            
    def save_bulk_words(self):
        text = self.bulk_text.get(1.0, tk.END).strip()
        if not text:
            messagebox.showwarning("Uyarı", "Lütfen kelime listesini girin!")
            return
            
        lines = text.split('\n')
        added_count = 0
        error_count = 0
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            parts = line.split('|')
            if len(parts) < 2:
                error_count += 1
                continue
                
            turkish = parts[0].strip()
            arabic = parts[1].strip()
            category_name = parts[2].strip() if len(parts) > 2 else None
            
            if not turkish or not arabic:
                error_count += 1
                continue
                
            # Kategori işlemleri
            if category_name:
                category_id = self.create_category(category_name)
            else:
                category_id = None
                
            try:
                # Kelimeyi veritabanına ekle
                self.cursor.execute('''
                INSERT INTO words (turkish, arabic, category_id)
                VALUES (?, ?, ?)
                ''', (turkish, arabic, category_id))
                
                word_id = self.cursor.lastrowid
                
                # Kelime ilerlemesini ekle
                self.cursor.execute('''
                INSERT INTO word_progress (word_id, profile_id, difficulty)
                VALUES (?, ?, ?)
                ''', (word_id, self.current_profile_id, 1))
                
                added_count += 1
            except Exception as e:
                print(f"Kelime eklenirken hata: {e}")
                error_count += 1
                
        self.conn.commit()
        
        # Verileri yeniden yükle
        self.load_data()
        
        messagebox.showinfo("İşlem Tamam", 
                          f"{added_count} kelime başarıyla eklendi.\n"
                          f"{error_count} hata oluştu.")
        
        # Metin alanını temizle
        self.bulk_text.delete(1.0, tk.END)
        
    def show_practice(self):
        self.clear_frame()
        self.current_page = "practice"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["word_practice"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Kategori seçimi
        category_frame = tk.Frame(self.root, bg=self.colors["bg"])
        category_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            category_frame,
            text="Kategori:",
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.practice_category_var = tk.StringVar()
        self.practice_category_combobox = ttk.Combobox(
            category_frame,
            textvariable=self.practice_category_var,
            font=("Arial", 12),
            width=30
        )
        self.practice_category_combobox.pack(side=tk.LEFT, padx=10)
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            self.practice_category_combobox['values'] = categories
            if categories:
                self.practice_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Başlat butonu
        start_btn = tk.Button(
            category_frame,
            text=self.texts["start"],
            command=self.start_practice,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        start_btn.pack(side=tk.LEFT, padx=10)
        
        # Pratik alanı
        self.practice_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.practice_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Başlangıç mesajı
        tk.Label(
            self.practice_frame,
            text=self.texts["select_category"],
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(expand=True)
        
    def start_practice(self):
        category_name = self.practice_category_var.get()
        if not category_name:
            messagebox.showwarning("Uyarı", "Lütfen bir kategori seçin!")
            return
            
        # Kategori ID'sini al
        self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
        result = self.cursor.fetchone()
        if not result:
            messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin!")
            return
            
        category_id = result[0]
        
        # Kategoriye ait kelimeleri al
        self.cursor.execute("SELECT * FROM words WHERE category_id=? ORDER BY RANDOM()", (category_id,))
        self.current_quiz = self.cursor.fetchall()
        
        if not self.current_quiz:
            messagebox.showinfo("Bilgi", "Bu kategoride kelime bulunamadı!")
            return
            
        self.current_question_index = 0
        self.quiz_start_time = time.time()
        self.quiz_answered = False
        
        # Pratik alanını temizle
        for widget in self.practice_frame.winfo_children():
            widget.destroy()
            
        # İlk soruyu göster
        self.show_practice_question()
        
    def show_practice_question(self):
        if self.current_question_index >= len(self.current_quiz):
            self.finish_practice()
            return
            
        # Önceki sorunun zamanlayıcısını iptal et
        if self.auto_next_timer:
            self.root.after_cancel(self.auto_next_timer)
            self.auto_next_timer = None
            
        # Soruyu al
        word = self.current_quiz[self.current_question_index]
        word_id, turkish, arabic, image_path, audio_path, category_id, difficulty, notes, created_at = word
        
        self.current_correct_word = word
        self.quiz_answered = False
        
        # Pratik alanını temizle
        for widget in self.practice_frame.winfo_children():
            widget.destroy()
            
        # Soru çerçevesi
        question_frame = tk.Frame(self.practice_frame, bg=self.colors["card_bg"])
        question_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Soru başlığı
        tk.Label(
            question_frame,
            text=f"{self.texts['question']} {self.current_question_index + 1}/{len(self.current_quiz)}",
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=10)
        
        # Ses butonu
        if audio_path and os.path.exists(audio_path):
            listen_btn = tk.Button(
                question_frame,
                text=self.texts["listen_again"],
                command=lambda: self.play_audio(audio_path),
                bg=self.colors["button_bg"],
                fg=self.colors["button_fg"],
                font=("Arial", 12),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            listen_btn.pack(pady=10)
        
        # Türkçe kelime
        self.current_shown_word = turkish
        tk.Label(
            question_frame,
            text=turkish,
            font=("Arial", 24, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # Butonlar
        button_frame = tk.Frame(question_frame, bg=self.colors["card_bg"])
        button_frame.pack(pady=20)
        
        correct_btn = tk.Button(
            button_frame,
            text=self.texts["correct"],
            command=lambda: self.answer_practice_question(True),
            bg=self.colors["correct_bg"],
            fg="white",
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        correct_btn.pack(side=tk.LEFT, padx=10)
        
        wrong_btn = tk.Button(
            button_frame,
            text=self.texts["wrong"],
            command=lambda: self.answer_practice_question(False),
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        wrong_btn.pack(side=tk.LEFT, padx=10)
        
        # Ses çal
        if audio_path and os.path.exists(audio_path):
            try:
                pygame.mixer.music.load(audio_path)
                pygame.mixer.music.play()
            except Exception as e:
                print(f"Ses çalınırken hata: {e}")
                
    def answer_practice_question(self, is_correct):
        if self.quiz_answered:
            return
            
        self.quiz_answered = True
        
        # Doğru cevabı göster
        word_id, turkish, arabic, image_path, audio_path, category_id, difficulty, notes, created_at = self.current_correct_word
        
        # Pratik alanını temizle
        for widget in self.practice_frame.winfo_children():
            widget.destroy()
            
        # Sonuç çerçevesi
        result_frame = tk.Frame(self.practice_frame, bg=self.colors["card_bg"])
        result_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Sonuç başlığı
        result_text = self.texts["correct"] if is_correct else self.texts["wrong"]
        result_color = self.colors["correct_bg"] if is_correct else self.colors["wrong_bg"]
        
        tk.Label(
            result_frame,
            text=result_text,
            font=("Arial", 20, "bold"),
            bg=self.colors["card_bg"],
            fg=result_color
        ).pack(pady=10)
        
        # Türkçe kelime
        tk.Label(
            result_frame,
            text=turkish,
            font=("Arial", 18),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=5)
        
        # Arapça kelime
        tk.Label(
            result_frame,
            text=arabic,
            font=("Arial", 18, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=5)
        
        # Resim
        if image_path and os.path.exists(image_path):
            try:
                img = Image.open(image_path)
                img = img.resize((200, 200), Image.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                
                img_label = tk.Label(result_frame, image=photo, bg=self.colors["card_bg"])
                img_label.image = photo  # Referansı tut
                img_label.pack(pady=10)
            except Exception as e:
                print(f"Resim gösterilirken hata: {e}")
        
        # Notlar
        if notes:
            tk.Label(
                result_frame,
                text=f"Not: {notes}",
                font=("Arial", 12),
                bg=self.colors["card_bg"],
                fg="gray"
            ).pack(pady=5)
        
        # Ses butonu
        if audio_path and os.path.exists(audio_path):
            listen_btn = tk.Button(
                result_frame,
                text=self.texts["listen_again"],
                command=lambda: self.play_audio(audio_path),
                bg=self.colors["button_bg"],
                fg=self.colors["button_fg"],
                font=("Arial", 12),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            listen_btn.pack(pady=10)
        
        # Sonraki butonu
        next_btn = tk.Button(
            result_frame,
            text=self.texts["next"],
            command=self.next_practice_question,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        next_btn.pack(pady=20)
        
        # İstatistikleri güncelle
        if is_correct:
            self.stats['correct'] += 1
        else:
            self.stats['wrong'] += 1
            
        # Kelime ilerlemesini güncelle
        try:
            if is_correct:
                self.cursor.execute('''
                UPDATE word_progress 
                SET correct_count = correct_count + 1, last_practiced = CURRENT_TIMESTAMP
                WHERE word_id = ? AND profile_id = ?
                ''', (word_id, self.current_profile_id))
            else:
                self.cursor.execute('''
                UPDATE word_progress 
                SET wrong_count = wrong_count + 1, last_practiced = CURRENT_TIMESTAMP
                WHERE word_id = ? AND profile_id = ?
                ''', (word_id, self.current_profile_id))
                
            self.conn.commit()
        except Exception as e:
            print(f"Kelime ilerlemesi güncellenirken hata: {e}")
            
        # Otomatik olarak sonraki soruya geç
        self.auto_next_timer = self.root.after(3000, self.next_practice_question)
        
    def next_practice_question(self):
        if self.auto_next_timer:
            self.root.after_cancel(self.auto_next_timer)
            self.auto_next_timer = None
            
        self.current_question_index += 1
        self.show_practice_question()
        
    def finish_practice(self):
        # Pratik alanını temizle
        for widget in self.practice_frame.winfo_children():
            widget.destroy()
            
        # Süreyi hesapla
        duration = int(time.time() - self.quiz_start_time)
        minutes = duration // 60
        seconds = duration % 60
        
        # Sonuç çerçevesi
        result_frame = tk.Frame(self.practice_frame, bg=self.colors["card_bg"])
        result_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Sonuç başlığı
        tk.Label(
            result_frame,
            text=self.texts["practice_completed"],
            font=("Arial", 20, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # Ana menüye dön butonu
        main_menu_btn = tk.Button(
            result_frame,
            text="Ana Menü",
            command=self.create_main_page,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        main_menu_btn.pack(pady=20)
        
        # İstatistikleri kaydet
        self.stats['total_time'] += duration
        self.save_stats()
        
        # Sınav sonucunu kaydet
        try:
            category_name = self.practice_category_var.get()
            self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
            category_result = self.cursor.fetchone()
            category_id = category_result[0] if category_result else None
            
            self.cursor.execute('''
            INSERT INTO exam_results (exam_type, category_id, profile_id, score, total_questions, duration)
            VALUES (?, ?, ?, ?, ?, ?)
            ''', ("practice", category_id, self.current_profile_id, self.stats['correct'], len(self.current_quiz), duration))
            
            self.conn.commit()
        except Exception as e:
            print(f"Sınav sonucu kaydedilirken hata: {e}")
            
    def play_audio(self, audio_path):
        try:
            pygame.mixer.music.load(audio_path)
            pygame.mixer.music.play()
        except Exception as e:
            print(f"Ses çalınırken hata: {e}")
            
    def show_memorize(self):
        self.clear_frame()
        self.current_page = "memorize"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["memorize"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Ayarlar çerçevesi
        settings_frame = tk.Frame(self.root, bg=self.colors["bg"])
        settings_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Kategori seçimi
        tk.Label(
            settings_frame,
            text="Kategori:",
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.memorize_category_var = tk.StringVar()
        self.memorize_category_combobox = ttk.Combobox(
            settings_frame,
            textvariable=self.memorize_category_var,
            font=("Arial", 12),
            width=20
        )
        self.memorize_category_combobox.pack(side=tk.LEFT, padx=10)
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            self.memorize_category_combobox['values'] = categories
            if categories:
                self.memorize_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Mod seçimi
        tk.Label(
            settings_frame,
            text="Mod:",
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.memorize_mode_var = tk.StringVar(value="slayt")
        mode_frame = tk.Frame(settings_frame, bg=self.colors["bg"])
        mode_frame.pack(side=tk.LEFT, padx=10)
        
        tk.Radiobutton(
            mode_frame,
            text=self.texts["slayt_mode"],
            variable=self.memorize_mode_var,
            value="slayt",
            bg=self.colors["bg"],
            fg=self.colors["fg"],
            command=self.update_memorize_mode
        ).pack(side=tk.LEFT)
        
        tk.Radiobutton(
            mode_frame,
            text=self.texts["manuel_mode"],
            variable=self.memorize_mode_var,
            value="manuel",
            bg=self.colors["bg"],
            fg=self.colors["fg"],
            command=self.update_memorize_mode
        ).pack(side=tk.LEFT)
        
        # Geçiş süresi
        tk.Label(
            settings_frame,
            text=self.texts["transition_time"],
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.memorize_time_var = tk.StringVar(value="3")
        time_entry = tk.Entry(
            settings_frame,
            textvariable=self.memorize_time_var,
            font=("Arial", 12),
            width=5
        )
        time_entry.pack(side=tk.LEFT, padx=5)
        
        tk.Label(
            settings_frame,
            text="saniye",
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT)
        
        # Başlat butonu
        start_btn = tk.Button(
            settings_frame,
            text=self.texts["start"],
            command=self.start_memorize,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        start_btn.pack(side=tk.LEFT, padx=10)
        
        # Ezber alanı
        self.memorize_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.memorize_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Başlangıç mesajı
        tk.Label(
            self.memorize_frame,
            text="Başlamak için bir kategori seçip 'Başla' butonuna tıklayın",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(expand=True)
        
    def update_memorize_mode(self):
        self.memorize_mode = self.memorize_mode_var.get()
        
    def start_memorize(self):
        category_name = self.memorize_category_var.get()
        if not category_name:
            messagebox.showwarning("Uyarı", "Lütfen bir kategori seçin!")
            return
            
        # Kategori ID'sini al
        self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
        result = self.cursor.fetchone()
        if not result:
            messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin!")
            return
            
        category_id = result[0]
        
        # Kategoriye ait kelimeleri al
        self.cursor.execute("SELECT * FROM words WHERE category_id=? ORDER BY RANDOM()", (category_id,))
        self.memorize_words = self.cursor.fetchall()
        
        if not self.memorize_words:
            messagebox.showinfo("Bilgi", "Bu kategoride kelime bulunamadı!")
            return
            
        self.memorize_index = 0
        self.memorize_mode = self.memorize_mode_var.get()
        self.memorize_paused = False
        
        # Geçiş süresini al
        try:
            self.memorize_transition_time = float(self.memorize_time_var.get())
        except ValueError:
            self.memorize_transition_time = 3.0
            
        # Ezber alanını temizle
        for widget in self.memorize_frame.winfo_children():
            widget.destroy()
            
        # İlk kelimeyi göster
        self.show_memorize_word()
        
    def show_memorize_word(self):
        if self.memorize_index >= len(self.memorize_words):
            self.finish_memorize()
            return
            
        # Önceki kelimenin zamanlayıcısını iptal et
        if self.memorize_timer:
            self.root.after_cancel(self.memorize_timer)
            self.memorize_timer = None
            
        # Kelimeyi al
        word = self.memorize_words[self.memorize_index]
        word_id, turkish, arabic, image_path, audio_path, category_id, difficulty, notes, created_at = word
        
        # Ezber alanını temizle
        for widget in self.memorize_frame.winfo_children():
            widget.destroy()
            
        # Kelime çerçevesi
        word_frame = tk.Frame(self.memorize_frame, bg=self.colors["card_bg"])
        word_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # İlerleme çubuğu
        progress_frame = tk.Frame(word_frame, bg=self.colors["card_bg"])
        progress_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            progress_frame,
            text=f"{self.memorize_index + 1}/{len(self.memorize_words)}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT)
        
        # Türkçe kelime
        tk.Label(
            word_frame,
            text=turkish,
            font=("Arial", 28, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # Arapça kelime
        tk.Label(
            word_frame,
            text=arabic,
            font=("Arial", 28, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["accent"]
        ).pack(pady=20)
        
        # Resim
        if image_path and os.path.exists(image_path):
            try:
                img = Image.open(image_path)
                img = img.resize((250, 250), Image.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                
                img_label = tk.Label(word_frame, image=photo, bg=self.colors["card_bg"])
                img_label.image = photo  # Referansı tut
                img_label.pack(pady=10)
            except Exception as e:
                print(f"Resim gösterilirken hata: {e}")
        
        # Notlar
        if notes:
            tk.Label(
                word_frame,
                text=f"Not: {notes}",
                font=("Arial", 12),
                bg=self.colors["card_bg"],
                fg="gray"
            ).pack(pady=5)
        
        # Ses çal
        if audio_path and os.path.exists(audio_path):
            try:
                pygame.mixer.music.load(audio_path)
                pygame.mixer.music.play()
            except Exception as e:
                print(f"Ses çalınırken hata: {e}")
        
        # Butonlar
        button_frame = tk.Frame(word_frame, bg=self.colors["card_bg"])
        button_frame.pack(pady=20)
        
        # Önceki butonu
        prev_btn = tk.Button(
            button_frame,
            text=self.texts["previous"],
            command=self.prev_memorize_word,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        prev_btn.pack(side=tk.LEFT, padx=10)
        
        # Duraklat/Devam butonu
        if self.memorize_paused:
            pause_resume_btn = tk.Button(
                button_frame,
                text=self.texts["resume"],
                command=self.toggle_memorize_pause,
                bg="#27ae60",
                fg="white",
                font=("Arial", 12, "bold"),
                relief=tk.FLAT,
                padx=20,
                pady=10
            )
        else:
            pause_resume_btn = tk.Button(
                button_frame,
                text=self.texts["pause"],
                command=self.toggle_memorize_pause,
                bg="#f39c12",
                fg="white",
                font=("Arial", 12, "bold"),
                relief=tk.FLAT,
                padx=20,
                pady=10
            )
        pause_resume_btn.pack(side=tk.LEFT, padx=10)
        
        # Sonraki butonu
        next_btn = tk.Button(
            button_frame,
            text=self.texts["next"],
            command=self.next_memorize_word,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        next_btn.pack(side=tk.LEFT, padx=10)
        
        # Bitir butonu
        finish_btn = tk.Button(
            button_frame,
            text=self.texts["finish"],
            command=self.finish_memorize,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        finish_btn.pack(side=tk.LEFT, padx=10)
        
        # Slayt modunda ise otomatik geçiş ayarla
        if self.memorize_mode == "slayt" and not self.memorize_paused:
            self.memorize_timer = self.root.after(int(self.memorize_transition_time * 1000), self.next_memorize_word)
            
    def toggle_memorize_pause(self):
        self.memorize_paused = not self.memorize_paused
        
        # Mevcut kelimeyi yeniden göster
        self.show_memorize_word()
        
    def prev_memorize_word(self):
        if self.memorize_index > 0:
            self.memorize_index -= 1
            self.show_memorize_word()
            
    def next_memorize_word(self):
        self.memorize_index += 1
        self.show_memorize_word()
        
    def finish_memorize(self):
        # Zamanlayıcıyı iptal et
        if self.memorize_timer:
            self.root.after_cancel(self.memorize_timer)
            self.memorize_timer = None
            
        # Ezber alanını temizle
        for widget in self.memorize_frame.winfo_children():
            widget.destroy()
            
        # Sonuç çerçevesi
        result_frame = tk.Frame(self.memorize_frame, bg=self.colors["card_bg"])
        result_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Sonuç başlığı
        tk.Label(
            result_frame,
            text=self.texts["memorize_completed"],
            font=("Arial", 20, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # Ana menüye dön butonu
        main_menu_btn = tk.Button(
            result_frame,
            text="Ana Menü",
            command=self.create_main_page,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        main_menu_btn.pack(pady=20)
        
    def show_flashcards(self):
        self.clear_frame()
        self.current_page = "flashcards"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["flashcards"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Kategori seçimi
        category_frame = tk.Frame(self.root, bg=self.colors["bg"])
        category_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            category_frame,
            text="Kategori:",
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.flashcards_category_var = tk.StringVar()
        self.flashcards_category_combobox = ttk.Combobox(
            category_frame,
            textvariable=self.flashcards_category_var,
            font=("Arial", 12),
            width=30
        )
        self.flashcards_category_combobox.pack(side=tk.LEFT, padx=10)
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            self.flashcards_category_combobox['values'] = categories
            if categories:
                self.flashcards_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Başlat butonu
        start_btn = tk.Button(
            category_frame,
            text=self.texts["start"],
            command=self.start_flashcards,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        start_btn.pack(side=tk.LEFT, padx=10)
        
        # Flashcards alanı
        self.flashcards_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.flashcards_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Başlangıç mesajı
        tk.Label(
            self.flashcards_frame,
            text="Başlamak için bir kategori seçip 'Başla' butonuna tıklayın",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(expand=True)
        
    def start_flashcards(self):
        category_name = self.flashcards_category_var.get()
        if not category_name:
            messagebox.showwarning("Uyarı", "Lütfen bir kategori seçin!")
            return
            
        # Kategori ID'sini al
        self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
        result = self.cursor.fetchone()
        if not result:
            messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin!")
            return
            
        category_id = result[0]
        
        # Kategoriye ait kelimeleri al
        self.cursor.execute("SELECT * FROM words WHERE category_id=? ORDER BY RANDOM()", (category_id,))
        self.flashcards_words = self.cursor.fetchall()
        
        if not self.flashcards_words:
            messagebox.showinfo("Bilgi", "Bu kategoride kelime bulunamadı!")
            return
            
        self.flashcards_index = 0
        self.flashcards_paused = False
        
        # Flashcards alanını temizle
        for widget in self.flashcards_frame.winfo_children():
            widget.destroy()
            
        # İlk kartı göster
        self.show_flashcard()
        
    def show_flashcard(self):
        if self.flashcards_index >= len(self.flashcards_words):
            self.finish_flashcards()
            return
            
        # Kartı al
        word = self.flashcards_words[self.flashcards_index]
        word_id, turkish, arabic, image_path, audio_path, category_id, difficulty, notes, created_at = word
        
        # Flashcards alanını temizle
        for widget in self.flashcards_frame.winfo_children():
            widget.destroy()
            
        # Kart çerçevesi
        card_frame = tk.Frame(self.flashcards_frame, bg=self.colors["card_bg"])
        card_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # İlerleme çubuğu
        progress_frame = tk.Frame(card_frame, bg=self.colors["card_bg"])
        progress_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            progress_frame,
            text=f"{self.flashcards_index + 1}/{len(self.flashcards_words)}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT)
        
        # Zorluk seviyesi
        tk.Label(
            progress_frame,
            text=f"Zorluk: {self.flashcards_difficulty.get(word_id, 1)}/5",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.RIGHT)
        
        # Türkçe kelime
        tk.Label(
            card_frame,
            text=turkish,
            font=("Arial", 28, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # Arapça kelime
        tk.Label(
            card_frame,
            text=arabic,
            font=("Arial", 28, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["accent"]
        ).pack(pady=20)
        
        # Resim
        if image_path and os.path.exists(image_path):
            try:
                img = Image.open(image_path)
                img = img.resize((250, 250), Image.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                
                img_label = tk.Label(card_frame, image=photo, bg=self.colors["card_bg"])
                img_label.image = photo  # Referansı tut
                img_label.pack(pady=10)
            except Exception as e:
                print(f"Resim gösterilirken hata: {e}")
        
        # Notlar
        if notes:
            tk.Label(
                card_frame,
                text=f"Not: {notes}",
                font=("Arial", 12),
                bg=self.colors["card_bg"],
                fg="gray"
            ).pack(pady=5)
        
        # Ses çal
        if audio_path and os.path.exists(audio_path):
            try:
                pygame.mixer.music.load(audio_path)
                pygame.mixer.music.play()
            except Exception as e:
                print(f"Ses çalınırken hata: {e}")
        
        # Butonlar
        button_frame = tk.Frame(card_frame, bg=self.colors["card_bg"])
        button_frame.pack(pady=20)
        
        # Önceki butonu
        prev_btn = tk.Button(
            button_frame,
            text=self.texts["previous"],
            command=self.prev_flashcard,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        prev_btn.pack(side=tk.LEFT, padx=10)
        
        # Duraklat/Devam butonu
        if self.flashcards_paused:
            pause_resume_btn = tk.Button(
                button_frame,
                text=self.texts["resume"],
                command=self.toggle_flashcards_pause,
                bg="#27ae60",
                fg="white",
                font=("Arial", 12, "bold"),
                relief=tk.FLAT,
                padx=20,
                pady=10
            )
        else:
            pause_resume_btn = tk.Button(
                button_frame,
                text=self.texts["pause"],
                command=self.toggle_flashcards_pause,
                bg="#f39c12",
                fg="white",
                font=("Arial", 12, "bold"),
                relief=tk.FLAT,
                padx=20,
                pady=10
            )
        pause_resume_btn.pack(side=tk.LEFT, padx=10)
        
        # Sonraki butonu
        next_btn = tk.Button(
            button_frame,
            text=self.texts["next"],
            command=self.next_flashcard,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        next_btn.pack(side=tk.LEFT, padx=10)
        
        # Zorluk butonları
        difficulty_frame = tk.Frame(card_frame, bg=self.colors["card_bg"])
        difficulty_frame.pack(pady=10)
        
        tk.Label(
            difficulty_frame,
            text="Zorluk:",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=5)
        
        for i in range(1, 6):
            diff_btn = tk.Button(
                difficulty_frame,
                text=str(i),
                command=lambda d=i: self.set_flashcard_difficulty(d),
                bg=self.colors["button_bg"] if i == self.flashcards_difficulty.get(word_id, 1) else "#95a5a6",
                fg=self.colors["button_fg"],
                font=("Arial", 10, "bold"),
                relief=tk.FLAT,
                padx=10,
                pady=5
            )
            diff_btn.pack(side=tk.LEFT, padx=2)
        
    def toggle_flashcards_pause(self):
        self.flashcards_paused = not self.flashcards_paused
        
        # Mevcut kartı yeniden göster
        self.show_flashcard()
        
    def prev_flashcard(self):
        if self.flashcards_index > 0:
            self.flashcards_index -= 1
            self.show_flashcard()
            
    def next_flashcard(self):
        self.flashcards_index += 1
        self.show_flashcard()
        
    def set_flashcard_difficulty(self, difficulty):
        word_id = self.flashcards_words[self.flashcards_index][0]
        self.flashcards_difficulty[word_id] = difficulty
        
        # Veritabanını güncelle
        try:
            self.cursor.execute('''
            UPDATE word_progress 
            SET difficulty = ?, last_practiced = CURRENT_TIMESTAMP
            WHERE word_id = ? AND profile_id = ?
            ''', (difficulty, word_id, self.current_profile_id))
            
            self.conn.commit()
        except Exception as e:
            print(f"Zorluk seviyesi güncellenirken hata: {e}")
            
        # Kartı yeniden göster
        self.show_flashcard()
        
    def finish_flashcards(self):
        # Flashcards alanını temizle
        for widget in self.flashcards_frame.winfo_children():
            widget.destroy()
            
        # Sonuç çerçevesi
        result_frame = tk.Frame(self.flashcards_frame, bg=self.colors["card_bg"])
        result_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Sonuç başlığı
        tk.Label(
            result_frame,
            text=self.texts["flashcards_completed"],
            font=("Arial", 20, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # Ana menüye dön butonu
        main_menu_btn = tk.Button(
            result_frame,
            text="Ana Menü",
            command=self.create_main_page,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        main_menu_btn.pack(pady=20)
        
    def show_sentence_practice(self):
        self.clear_frame()
        self.current_page = "sentence_practice"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["sentence_practice"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Kategori seçimi
        category_frame = tk.Frame(self.root, bg=self.colors["bg"])
        category_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            category_frame,
            text="Kategori:",
            font=("Arial", 12),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.sentence_practice_category_var = tk.StringVar()
        self.sentence_practice_category_combobox = ttk.Combobox(
            category_frame,
            textvariable=self.sentence_practice_category_var,
            font=("Arial", 12),
            width=30
        )
        self.sentence_practice_category_combobox.pack(side=tk.LEFT, padx=10)
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            self.sentence_practice_category_combobox['values'] = categories
            if categories:
                self.sentence_practice_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Başlat butonu
        start_btn = tk.Button(
            category_frame,
            text=self.texts["start"],
            command=self.start_sentence_practice,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        start_btn.pack(side=tk.LEFT, padx=10)
        
        # Cümle çalışması alanı
        self.sentence_practice_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.sentence_practice_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Başlangıç mesajı
        tk.Label(
            self.sentence_practice_frame,
            text="Başlamak için bir kategori seçip 'Başla' butonuna tıklayın",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(expand=True)
        
    def start_sentence_practice(self):
        category_name = self.sentence_practice_category_var.get()
        if not category_name:
            messagebox.showwarning("Uyarı", "Lütfen bir kategori seçin!")
            return
            
        # Kategori ID'sini al
        self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
        result = self.cursor.fetchone()
        if not result:
            messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin!")
            return
            
        category_id = result[0]
        
        # Kategoriye ait cümleleri al
        self.cursor.execute("SELECT * FROM sentences WHERE category_id=? ORDER BY RANDOM()", (category_id,))
        self.sentence_practice_words = self.cursor.fetchall()
        
        if not self.sentence_practice_words:
            messagebox.showinfo("Bilgi", "Bu kategoride cümle bulunamadı!")
            return
            
        self.sentence_practice_index = 0
        
        # Cümle çalışması alanını temizle
        for widget in self.sentence_practice_frame.winfo_children():
            widget.destroy()
            
        # İlk cümleyi göster
        self.show_sentence_practice_question()
        
    def show_sentence_practice_question(self):
        if self.sentence_practice_index >= len(self.sentence_practice_words):
            self.finish_sentence_practice()
            return
            
        # Cümleyi al
        sentence = self.sentence_practice_words[self.sentence_practice_index]
        sentence_id, turkish, arabic, audio_path, category_id, difficulty, created_at = sentence
        
        # Cümle çalışması alanını temizle
        for widget in self.sentence_practice_frame.winfo_children():
            widget.destroy()
            
        # Cümle çerçevesi
        sentence_frame = tk.Frame(self.sentence_practice_frame, bg=self.colors["card_bg"])
        sentence_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # İlerleme çubuğu
        progress_frame = tk.Frame(sentence_frame, bg=self.colors["card_bg"])
        progress_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            progress_frame,
            text=f"{self.sentence_practice_index + 1}/{len(self.sentence_practice_words)}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT)
        
        # Türkçe cümle
        tk.Label(
            sentence_frame,
            text=turkish,
            font=("Arial", 18),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"],
            wraplength=600
        ).pack(pady=20)
        
        # Arapça cümle
        tk.Label(
            sentence_frame,
            text=arabic,
            font=("Arial", 18, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["accent"],
            wraplength=600
        ).pack(pady=20)
        
        # Ses butonu
        if audio_path and os.path.exists(audio_path):
            listen_btn = tk.Button(
                sentence_frame,
                text=self.texts["listen_again"],
                command=lambda: self.play_audio(audio_path),
                bg=self.colors["button_bg"],
                fg=self.colors["button_fg"],
                font=("Arial", 12),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            listen_btn.pack(pady=10)
        else:
            # Ses dosyası oluştur
            try:
                audio_filename = f"{self.sanitize_filename(turkish[:20])}_{sentence_id}.mp3"
                audio_path = os.path.join("sesler", audio_filename)
                
                tts = gTTS(text=arabic, lang='ar')
                tts.save(audio_path)
                
                # Veritabanını güncelle
                self.cursor.execute("UPDATE sentences SET audio_path=? WHERE id=?", (audio_path, sentence_id))
                self.conn.commit()
                
                # Ses butonu
                listen_btn = tk.Button(
                    sentence_frame,
                    text=self.texts["listen_again"],
                    command=lambda: self.play_audio(audio_path),
                    bg=self.colors["button_bg"],
                    fg=self.colors["button_fg"],
                    font=("Arial", 12),
                    relief=tk.FLAT,
                    padx=20,
                    pady=5
                )
                listen_btn.pack(pady=10)
            except Exception as e:
                print(f"Ses dosyası oluşturulurken hata: {e}")
        
        # Butonlar
        button_frame = tk.Frame(sentence_frame, bg=self.colors["card_bg"])
        button_frame.pack(pady=20)
        
        # Önceki butonu
        prev_btn = tk.Button(
            button_frame,
            text=self.texts["previous"],
            command=self.prev_sentence_practice,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        prev_btn.pack(side=tk.LEFT, padx=10)
        
        # Sonraki butonu
        next_btn = tk.Button(
            button_frame,
            text=self.texts["next"],
            command=self.next_sentence_practice,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        next_btn.pack(side=tk.LEFT, padx=10)
        
        # Ses çal
        if audio_path and os.path.exists(audio_path):
            try:
                pygame.mixer.music.load(audio_path)
                pygame.mixer.music.play()
            except Exception as e:
                print(f"Ses çalınırken hata: {e}")
                
    def prev_sentence_practice(self):
        if self.sentence_practice_index > 0:
            self.sentence_practice_index -= 1
            self.show_sentence_practice_question()
            
    def next_sentence_practice(self):
        self.sentence_practice_index += 1
        self.show_sentence_practice_question()
        
    def finish_sentence_practice(self):
        # Cümle çalışması alanını temizle
        for widget in self.sentence_practice_frame.winfo_children():
            widget.destroy()
            
        # Sonuç çerçevesi
        result_frame = tk.Frame(self.sentence_practice_frame, bg=self.colors["card_bg"])
        result_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Sonuç başlığı
        tk.Label(
            result_frame,
            text="Cümle Çalışması Tamamlandı!",
            font=("Arial", 20, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # Ana menüye dön butonu
        main_menu_btn = tk.Button(
            result_frame,
            text="Ana Menü",
            command=self.create_main_page,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        main_menu_btn.pack(pady=20)
        
    def show_exam_mode(self):
        self.clear_frame()
        self.current_page = "exam_mode"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["exam_mode"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Sınav ayarları
        settings_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        settings_frame.pack(fill=tk.X, padx=50, pady=20)
        
        # Kategori seçimi
        tk.Label(
            settings_frame,
            text="Kategori:",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).grid(row=0, column=0, sticky="w", padx=20, pady=10)
        
        self.exam_category_var = tk.StringVar()
        self.exam_category_combobox = ttk.Combobox(
            settings_frame,
            textvariable=self.exam_category_var,
            font=("Arial", 12),
            width=30
        )
        self.exam_category_combobox.grid(row=0, column=1, padx=20, pady=10, sticky="w")
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            self.exam_category_combobox['values'] = categories
            if categories:
                self.exam_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Soru sayısı
        tk.Label(
            settings_frame,
            text="Soru Sayısı:",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).grid(row=1, column=0, sticky="w", padx=20, pady=10)
        
        self.exam_question_count_var = tk.StringVar(value="10")
        question_count_entry = tk.Entry(
            settings_frame,
            textvariable=self.exam_question_count_var,
            font=("Arial", 12),
            width=10
        )
        question_count_entry.grid(row=1, column=1, padx=20, pady=10, sticky="w")
        
        # Sınav türü
        tk.Label(
            settings_frame,
            text="Sınav Türü:",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).grid(row=2, column=0, sticky="w", padx=20, pady=10)
        
        self.exam_type_var = tk.StringVar(value="kelime")
        exam_type_frame = tk.Frame(settings_frame, bg=self.colors["card_bg"])
        exam_type_frame.grid(row=2, column=1, padx=20, pady=10, sticky="w")
        
        tk.Radiobutton(
            exam_type_frame,
            text="Kelime",
            variable=self.exam_type_var,
            value="kelime",
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT)
        
        tk.Radiobutton(
            exam_type_frame,
            text="Cümle",
            variable=self.exam_type_var,
            value="cümle",
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT)
        
        # Zorluk seviyesi
        tk.Label(
            settings_frame,
            text="Zorluk Seviyesi:",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).grid(row=3, column=0, sticky="w", padx=20, pady=10)
        
        self.exam_difficulty_var = tk.StringVar(value="tümü")
        difficulty_frame = tk.Frame(settings_frame, bg=self.colors["card_bg"])
        difficulty_frame.grid(row=3, column=1, padx=20, pady=10, sticky="w")
        
        tk.Radiobutton(
            difficulty_frame,
            text="Tümü",
            variable=self.exam_difficulty_var,
            value="tümü",
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT)
        
        for i in range(1, 6):
            tk.Radiobutton(
                difficulty_frame,
                text=str(i),
                variable=self.exam_difficulty_var,
                value=str(i),
                bg=self.colors["card_bg"],
                fg=self.colors["fg"]
            ).pack(side=tk.LEFT)
        
        # Başlat butonu
        start_btn = tk.Button(
            settings_frame,
            text=self.texts["start"],
            command=self.start_exam,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        start_btn.grid(row=4, column=0, columnspan=2, pady=20)
        
        # Sınav alanı
        self.exam_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.exam_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Başlangıç mesajı
        tk.Label(
            self.exam_frame,
            text="Sınava başlamak için ayarları yapıp 'Başla' butonuna tıklayın",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(expand=True)
        
    def start_exam(self):
        category_name = self.exam_category_var.get()
        if not category_name:
            messagebox.showwarning("Uyarı", "Lütfen bir kategori seçin!")
            return
            
        # Kategori ID'sini al
        self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
        result = self.cursor.fetchone()
        if not result:
            messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin!")
            return
            
        category_id = result[0]
        
        # Soru sayısını al
        try:
            question_count = int(self.exam_question_count_var.get())
            if question_count <= 0:
                raise ValueError
        except ValueError:
            messagebox.showwarning("Uyarı", "Lütfen geçerli bir soru sayısı girin!")
            return
            
        # Sınav türünü al
        exam_type = self.exam_type_var.get()
        
        # Zorluk seviyesini al
        difficulty = self.exam_difficulty_var.get()
        
        # Soruları al
        if exam_type == "kelime":
            if difficulty == "tümü":
                self.cursor.execute("SELECT * FROM words WHERE category_id=? ORDER BY RANDOM() LIMIT ?", (category_id, question_count))
            else:
                self.cursor.execute("SELECT * FROM words WHERE category_id=? AND difficulty=? ORDER BY RANDOM() LIMIT ?", (category_id, int(difficulty), question_count))
            self.current_quiz = self.cursor.fetchall()
        else:  # cümle
            if difficulty == "tümü":
                self.cursor.execute("SELECT * FROM sentences WHERE category_id=? ORDER BY RANDOM() LIMIT ?", (category_id, question_count))
            else:
                self.cursor.execute("SELECT * FROM sentences WHERE category_id=? AND difficulty=? ORDER BY RANDOM() LIMIT ?", (category_id, int(difficulty), question_count))
            self.current_quiz = self.cursor.fetchall()
            
        if not self.current_quiz:
            messagebox.showinfo("Bilgi", "Bu kategoride yeterli sayıda soru bulunamadı!")
            return
            
        self.current_question_index = 0
        self.quiz_start_time = time.time()
        self.quiz_answered = False
        self.exam_score = 0
        
        # Sınav alanını temizle
        for widget in self.exam_frame.winfo_children():
            widget.destroy()
            
        # İlk soruyu göster
        self.show_exam_question()
        
    def show_exam_question(self):
        if self.current_question_index >= len(self.current_quiz):
            self.finish_exam()
            return
            
        # Önceki sorunun zamanlayıcısını iptal et
        if self.auto_next_timer:
            self.root.after_cancel(self.auto_next_timer)
            self.auto_next_timer = None
            
        # Soruyu al
        question = self.current_quiz[self.current_question_index]
        
        if len(question) == 9:  # Kelime
            question_id, turkish, arabic, image_path, audio_path, category_id, difficulty, notes, created_at = question
            is_word = True
        else:  # Cümle
            question_id, turkish, arabic, audio_path, category_id, difficulty, created_at = question
            is_word = False
            
        self.current_correct_answer = arabic
        self.quiz_answered = False
        
        # Sınav alanını temizle
        for widget in self.exam_frame.winfo_children():
            widget.destroy()
            
        # Soru çerçevesi
        question_frame = tk.Frame(self.exam_frame, bg=self.colors["card_bg"])
        question_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Soru başlığı
        tk.Label(
            question_frame,
            text=f"Soru {self.current_question_index + 1}/{len(self.current_quiz)}",
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=10)
        
        # Türkçe kelime/cümle
        tk.Label(
            question_frame,
            text=turkish,
            font=("Arial", 24, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"],
            wraplength=600
        ).pack(pady=20)
        
        # Resim (sadece kelime sorularında)
        if is_word and image_path and os.path.exists(image_path):
            try:
                img = Image.open(image_path)
                img = img.resize((200, 200), Image.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                
                img_label = tk.Label(question_frame, image=photo, bg=self.colors["card_bg"])
                img_label.image = photo  # Referansı tut
                img_label.pack(pady=10)
            except Exception as e:
                print(f"Resim gösterilirken hata: {e}")
        
        # Seçenekler
        options_frame = tk.Frame(question_frame, bg=self.colors["card_bg"])
        options_frame.pack(pady=20)
        
        # Doğru cevap
        correct_option = arabic
        
        # Yanlış seçenekler oluştur
        wrong_options = []
        
        if is_word:
            # Diğer kelimelerden rastgele seçimler yap
            self.cursor.execute("SELECT arabic FROM words WHERE id != ? ORDER BY RANDOM() LIMIT 3", (question_id,))
            wrong_options = [row[0] for row in self.cursor.fetchall()]
        else:
            # Diğer cümlelerden rastgele seçimler yap
            self.cursor.execute("SELECT arabic FROM sentences WHERE id != ? ORDER BY RANDOM() LIMIT 3", (question_id,))
            wrong_options = [row[0] for row in self.cursor.fetchall()]
            
        # Seçenekleri karıştır
        all_options = [correct_option] + wrong_options
        random.shuffle(all_options)
        
        # Seçenek butonları
        for i, option in enumerate(all_options):
            option_btn = tk.Button(
                options_frame,
                text=option,
                command=lambda opt=option, cor=correct_option: self.answer_exam_question(opt, cor),
                bg=self.colors["button_bg"],
                fg=self.colors["button_fg"],
                font=("Arial", 14),
                relief=tk.FLAT,
                padx=20,
                pady=10,
                width=30
            )
            option_btn.grid(row=i//2, column=i%2, padx=10, pady=10)
        
        # Butonlar
        button_frame = tk.Frame(question_frame, bg=self.colors["card_bg"])
        button_frame.pack(pady=20)
        
        # Önceki butonu
        prev_btn = tk.Button(
            button_frame,
            text=self.texts["previous"],
            command=self.prev_exam_question,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        prev_btn.pack(side=tk.LEFT, padx=10)
        
        # Duraklat/Devam butonu
        if hasattr(self, 'exam_paused') and self.exam_paused:
            pause_resume_btn = tk.Button(
                button_frame,
                text=self.texts["resume"],
                command=self.toggle_exam_pause,
                bg="#27ae60",
                fg="white",
                font=("Arial", 12, "bold"),
                relief=tk.FLAT,
                padx=20,
                pady=10
            )
        else:
            pause_resume_btn = tk.Button(
                button_frame,
                text=self.texts["pause"],
                command=self.toggle_exam_pause,
                bg="#f39c12",
                fg="white",
                font=("Arial", 12, "bold"),
                relief=tk.FLAT,
                padx=20,
                pady=10
            )
        pause_resume_btn.pack(side=tk.LEFT, padx=10)
        
        # Sonraki butonu
        next_btn = tk.Button(
            button_frame,
            text=self.texts["next"],
            command=self.next_exam_question,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        next_btn.pack(side=tk.LEFT, padx=10)
        
        # Bitir butonu
        finish_btn = tk.Button(
            button_frame,
            text=self.texts["finish"],
            command=self.finish_exam,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        finish_btn.pack(side=tk.LEFT, padx=10)
        
        # Ses çal
        if audio_path and os.path.exists(audio_path):
            try:
                pygame.mixer.music.load(audio_path)
                pygame.mixer.music.play()
            except Exception as e:
                print(f"Ses çalınırken hata: {e}")
                
    def toggle_exam_pause(self):
        if not hasattr(self, 'exam_paused'):
            self.exam_paused = False
            
        self.exam_paused = not self.exam_paused
        
        # Mevcut soruyu yeniden göster
        self.show_exam_question()
        
    def prev_exam_question(self):
        if self.current_question_index > 0:
            self.current_question_index -= 1
            self.show_exam_question()
            
    def next_exam_question(self):
        self.current_question_index += 1
        self.show_exam_question()
        
    def answer_exam_question(self, selected_answer, correct_answer):
        if self.quiz_answered:
            return
            
        self.quiz_answered = True
        
        # Doğruluğu kontrol et
        is_correct = (selected_answer == correct_answer)
        
        if is_correct:
            self.exam_score += 1
            
        # Sonucu göster
        question = self.current_quiz[self.current_question_index]
        
        if len(question) == 9:  # Kelime
            question_id, turkish, arabic, image_path, audio_path, category_id, difficulty, notes, created_at = question
            is_word = True
        else:  # Cümle
            question_id, turkish, arabic, audio_path, category_id, difficulty, created_at = question
            is_word = False
            
        # Sınav alanını temizle
        for widget in self.exam_frame.winfo_children():
            widget.destroy()
            
        # Sonuç çerçevesi
        result_frame = tk.Frame(self.exam_frame, bg=self.colors["card_bg"])
        result_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Sonuç başlığı
        result_text = "Doğru!" if is_correct else "Yanlış!"
        result_color = self.colors["correct_bg"] if is_correct else self.colors["wrong_bg"]
        
        tk.Label(
            result_frame,
            text=result_text,
            font=("Arial", 20, "bold"),
            bg=self.colors["card_bg"],
            fg=result_color
        ).pack(pady=10)
        
        # Türkçe kelime/cümle
        tk.Label(
            result_frame,
            text=turkish,
            font=("Arial", 18),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"],
            wraplength=600
        ).pack(pady=5)
        
        # Arapça kelime/cümle
        tk.Label(
            result_frame,
            text=arabic,
            font=("Arial", 18, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["accent"],
            wraplength=600
        ).pack(pady=5)
        
        # Resim (sadece kelime sorularında)
        if is_word and image_path and os.path.exists(image_path):
            try:
                img = Image.open(image_path)
                img = img.resize((200, 200), Image.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                
                img_label = tk.Label(result_frame, image=photo, bg=self.colors["card_bg"])
                img_label.image = photo  # Referansı tut
                img_label.pack(pady=10)
            except Exception as e:
                print(f"Resim gösterilirken hata: {e}")
        
        # Ses butonu
        if audio_path and os.path.exists(audio_path):
            listen_btn = tk.Button(
                result_frame,
                text=self.texts["listen_again"],
                command=lambda: self.play_audio(audio_path),
                bg=self.colors["button_bg"],
                fg=self.colors["button_fg"],
                font=("Arial", 12),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            listen_btn.pack(pady=10)
        
        # Sonraki butonu
        next_btn = tk.Button(
            result_frame,
            text=self.texts["next"],
            command=self.next_exam_question,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        next_btn.pack(pady=20)
        
        # İstatistikleri güncelle
        if is_correct:
            self.stats['correct'] += 1
        else:
            self.stats['wrong'] += 1
            
        # Otomatik olarak sonraki soruya geç
        self.auto_next_timer = self.root.after(3000, self.next_exam_question)
        
    def finish_exam(self):
        # Sınav alanını temizle
        for widget in self.exam_frame.winfo_children():
            widget.destroy()
            
        # Süreyi hesapla
        duration = int(time.time() - self.quiz_start_time)
        minutes = duration // 60
        seconds = duration % 60
        
        # Sonuç çerçevesi
        result_frame = tk.Frame(self.exam_frame, bg=self.colors["card_bg"])
        result_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)
        
        # Sonuç başlığı
        tk.Label(
            result_frame,
            text=self.texts["exam_completed"],
            font=("Arial", 20, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=20)
        
        # İstatistikler
        tk.Label(
            result_frame,
            text=f"Soru Sayısı: {len(self.current_quiz)}",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=5)
        
        tk.Label(
            result_frame,
            text=f"Doğru Sayısı: {self.exam_score}",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["correct_bg"]
        ).pack(pady=5)
        
        tk.Label(
            result_frame,
            text=f"Yanlış Sayısı: {len(self.current_quiz) - self.exam_score}",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["wrong_bg"]
        ).pack(pady=5)
        
        tk.Label(
            result_frame,
            text=f"Süre: {minutes}:{seconds:02d}",
            font=("Arial", 14),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(pady=5)
        
        # Başarı oranı
        if len(self.current_quiz) > 0:
            success_rate = (self.exam_score / len(self.current_quiz)) * 100
            tk.Label(
                result_frame,
                text=f"Başarı Oranı: {success_rate:.1f}%",
                font=("Arial", 14, "bold"),
                bg=self.colors["card_bg"],
                fg=self.colors["accent"]
            ).pack(pady=5)
        
        # Ana menüye dön butonu
        main_menu_btn = tk.Button(
            result_frame,
            text="Ana Menü",
            command=self.create_main_page,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 14, "bold"),
            relief=tk.FLAT,
            padx=30,
            pady=10
        )
        main_menu_btn.pack(pady=20)
        
        # İstatistikleri kaydet
        self.stats['total_time'] += duration
        self.save_stats()
        
        # Sınav sonucunu kaydet
        try:
            category_name = self.exam_category_var.get()
            self.cursor.execute("SELECT id FROM categories WHERE name=?", (category_name,))
            category_result = self.cursor.fetchone()
            category_id = category_result[0] if category_result else None
            
            self.cursor.execute('''
            INSERT INTO exam_results (exam_type, category_id, profile_id, score, total_questions, duration)
            VALUES (?, ?, ?, ?, ?, ?)
            ''', (self.exam_type_var.get(), category_id, self.current_profile_id, self.exam_score, len(self.current_quiz), duration))
            
            self.conn.commit()
        except Exception as e:
            print(f"Sınav sonucu kaydedilirken hata: {e}")
            
    def show_management(self):
        self.clear_frame()
        self.current_page = "management"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["management"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Sekmeler
        tabs_frame = tk.Frame(self.root, bg=self.colors["bg"])
        tabs_frame.pack(fill=tk.X, padx=20, pady=10)
        
        words_tab_btn = tk.Button(
            tabs_frame,
            text="Kelimeler",
            command=lambda: self.show_management_tab("words"),
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        words_tab_btn.pack(side=tk.LEFT, padx=5)
        
        sentences_tab_btn = tk.Button(
            tabs_frame,
            text="Cümleler",
            command=lambda: self.show_management_tab("sentences"),
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        sentences_tab_btn.pack(side=tk.LEFT, padx=5)
        
        categories_tab_btn = tk.Button(
            tabs_frame,
            text="Kategoriler",
            command=lambda: self.show_management_tab("categories"),
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        categories_tab_btn.pack(side=tk.LEFT, padx=5)
        
        # Yönetim alanı
        self.management_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.management_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Kelimeler sekmesini göster
        self.show_management_tab("words")
        
    def show_management_tab(self, tab_name):
        # Yönetim alanını temizle
        for widget in self.management_frame.winfo_children():
            widget.destroy()
            
        # Sekme butonlarını güncelle
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Frame) and widget == self.root.winfo_children()[2]:  # tabs_frame
                for btn in widget.winfo_children():
                    if isinstance(btn, tk.Button):
                        if tab_name == "words" and btn["text"] == "Kelimeler":
                            btn.config(bg=self.colors["button_bg"])
                        elif tab_name == "sentences" and btn["text"] == "Cümleler":
                            btn.config(bg=self.colors["button_bg"])
                        elif tab_name == "categories" and btn["text"] == "Kategoriler":
                            btn.config(bg=self.colors["button_bg"])
                        else:
                            btn.config(bg="#95a5a6")
        
        if tab_name == "words":
            self.show_words_management()
        elif tab_name == "sentences":
            self.show_sentences_management()
        elif tab_name == "categories":
            self.show_categories_management()
            
    def show_words_management(self):
        # Filtreleme çerçevesi
        filter_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        filter_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            filter_frame,
            text="Kategori:",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.words_filter_category_var = tk.StringVar()
        self.words_filter_category_combobox = ttk.Combobox(
            filter_frame,
            textvariable=self.words_filter_category_var,
            font=("Arial", 12),
            width=20
        )
        self.words_filter_category_combobox.pack(side=tk.LEFT, padx=10)
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = ["Tümü"] + [row[0] for row in self.cursor.fetchall()]
            self.words_filter_category_combobox['values'] = categories
            self.words_filter_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Ara butonu
        search_btn = tk.Button(
            filter_frame,
            text="Ara",
            command=self.search_words,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        search_btn.pack(side=tk.LEFT, padx=10)
        
        # Kelimeler tablosu
        table_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        table_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(table_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Treeview
        self.words_tree = ttk.Treeview(
            table_frame,
            columns=("id", "turkish", "arabic", "category", "difficulty"),
            show="headings",
            yscrollcommand=scrollbar.set
        )
        self.words_tree.pack(fill=tk.BOTH, expand=True)
        
        scrollbar.config(command=self.words_tree.yview)
        
        # Sütunları ayarla
        self.words_tree.heading("id", text="ID")
        self.words_tree.heading("turkish", text="Türkçe")
        self.words_tree.heading("arabic", text="Arapça")
        self.words_tree.heading("category", text="Kategori")
        self.words_tree.heading("difficulty", text="Zorluk")
        
        self.words_tree.column("id", width=50)
        self.words_tree.column("turkish", width=200)
        self.words_tree.column("arabic", width=200)
        self.words_tree.column("category", width=150)
        self.words_tree.column("difficulty", width=80)
        
        # Çift tıklama olayı
        self.words_tree.bind("<Double-1>", self.edit_word)
        
        # Butonlar
        buttons_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        buttons_frame.pack(fill=tk.X, padx=20, pady=10)
        
        edit_btn = tk.Button(
            buttons_frame,
            text=self.texts["edit_word"],
            command=self.edit_selected_word,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        edit_btn.pack(side=tk.LEFT, padx=5)
        
        delete_btn = tk.Button(
            buttons_frame,
            text="Sil",
            command=self.delete_selected_word,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        delete_btn.pack(side=tk.LEFT, padx=5)
        
        # Kelimeleri yükle
        self.load_words_table()
        
    def load_words_table(self):
        # Tabloyu temizle
        for item in self.words_tree.get_children():
            self.words_tree.delete(item)
            
        # Kelimeleri getir
        category_name = self.words_filter_category_var.get()
        
        if category_name == "Tümü":
            self.cursor.execute('''
            SELECT w.id, w.turkish, w.arabic, c.name, w.difficulty 
            FROM words w
            LEFT JOIN categories c ON w.category_id = c.id
            ORDER BY w.turkish
            ''')
        else:
            self.cursor.execute('''
            SELECT w.id, w.turkish, w.arabic, c.name, w.difficulty 
            FROM words w
            LEFT JOIN categories c ON w.category_id = c.id
            WHERE c.name = ?
            ORDER BY w.turkish
            ''', (category_name,))
            
        words = self.cursor.fetchall()
        
        # Tabloya ekle
        for word in words:
            self.words_tree.insert("", tk.END, values=word)
            
    def search_words(self):
        self.load_words_table()
        
    def edit_selected_word(self):
        selected_item = self.words_tree.selection()
        if not selected_item:
            messagebox.showwarning("Uyarı", "Lütfen düzenlemek için bir kelime seçin!")
            return
            
        word_id = self.words_tree.item(selected_item[0])['values'][0]
        self.edit_word_dialog(word_id)
        
    def edit_word(self, event):
        selected_item = self.words_tree.selection()
        if not selected_item:
            return
            
        word_id = self.words_tree.item(selected_item[0])['values'][0]
        self.edit_word_dialog(word_id)
        
    def edit_word_dialog(self, word_id):
        # Kelime bilgilerini al
        self.cursor.execute("SELECT * FROM words WHERE id=?", (word_id,))
        word = self.cursor.fetchone()
        
        if not word:
            messagebox.showerror("Hata", "Kelime bulunamadı!")
            return
            
        word_id, turkish, arabic, image_path, audio_path, category_id, difficulty, notes, created_at = word
        
        # Kategori adını al
        category_name = ""
        if category_id:
            self.cursor.execute("SELECT name FROM categories WHERE id=?", (category_id,))
            category_result = self.cursor.fetchone()
            if category_result:
                category_name = category_result[0]
        
        # Düzenleme penceresi
        dialog = tk.Toplevel(self.root)
        dialog.title(self.texts["edit_word"])
        dialog.geometry("600x700")
        dialog.configure(bg=self.colors["bg"])
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Başlık
        tk.Label(
            dialog,
            text=self.texts["edit_word"],
            font=("Arial", 16, "bold"),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(pady=10)
        
        # Form çerçevesi
        form_frame = tk.Frame(dialog, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        form_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Türkçe kelime
        tk.Label(form_frame, text=self.texts["turkish_word"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=0, column=0, sticky="w", padx=20, pady=10)
        turkish_var = tk.StringVar(value=turkish)
        turkish_entry = tk.Entry(form_frame, textvariable=turkish_var, font=("Arial", 12), width=40)
        turkish_entry.grid(row=0, column=1, padx=20, pady=10)
        
        # Arapça kelime
        tk.Label(form_frame, text=self.texts["arabic_word"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=1, column=0, sticky="w", padx=20, pady=10)
        arabic_var = tk.StringVar(value=arabic)
        arabic_entry = tk.Entry(form_frame, textvariable=arabic_var, font=("Arial", 12), width=40)
        arabic_entry.grid(row=1, column=1, padx=20, pady=10)
        
        # Kategori seçimi
        tk.Label(form_frame, text=self.texts["category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=2, column=0, sticky="w", padx=20, pady=10)
        
        category_var = tk.StringVar(value=category_name)
        category_combobox = ttk.Combobox(form_frame, textvariable=category_var, font=("Arial", 10), width=37)
        category_combobox.grid(row=2, column=1, padx=20, pady=10, sticky="w")
        
        # Mevcut kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            category_combobox['values'] = categories
            if categories and category_name in categories:
                category_combobox.current(categories.index(category_name))
            elif categories:
                category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Yeni kategori oluşturma
        tk.Label(form_frame, text=self.texts["new_category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=3, column=0, sticky="w", padx=20, pady=10)
        new_category_var = tk.StringVar()
        new_category_entry = tk.Entry(form_frame, textvariable=new_category_var, font=("Arial", 12), width=40)
        new_category_entry.grid(row=3, column=1, padx=20, pady=10)
        
        # Zorluk seviyesi
        tk.Label(form_frame, text=self.texts["difficulty"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=4, column=0, sticky="w", padx=20, pady=10)
        difficulty_var = tk.IntVar(value=difficulty)
        difficulty_frame = tk.Frame(form_frame, bg=self.colors["card_bg"])
        difficulty_frame.grid(row=4, column=1, padx=20, pady=10, sticky="w")
        
        for i in range(1, 6):
            tk.Radiobutton(
                difficulty_frame,
                text=str(i),
                variable=difficulty_var,
                value=i,
                bg=self.colors["card_bg"],
                fg=self.colors["fg"]
            ).pack(side=tk.LEFT, padx=5)
        
        # Notlar
        tk.Label(form_frame, text=self.texts["notes"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=5, column=0, sticky="w", padx=20, pady=10)
        notes_text = scrolledtext.ScrolledText(form_frame, width=40, height=5, font=("Arial", 10))
        notes_text.grid(row=5, column=1, padx=20, pady=10)
        notes_text.insert(tk.END, notes)
        
        # Resim seçimi
        tk.Label(form_frame, text=self.texts["select_image"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=6, column=0, sticky="w", padx=20, pady=10)
        image_path_var = tk.StringVar(value=image_path if image_path else "")
        image_frame = tk.Frame(form_frame, bg=self.colors["card_bg"])
        image_frame.grid(row=6, column=1, padx=20, pady=10, sticky="w")
        
        image_entry = tk.Entry(image_frame, textvariable=image_path_var, font=("Arial", 10), width=30)
        image_entry.pack(side=tk.LEFT)
        
        def browse_image_dialog():
            file_path = filedialog.askopenfilename(
                title="Resim Seç",
                filetypes=[("Image files", "*.jpg *.jpeg *.png *.gif *.bmp")]
            )
            
            if file_path:
                image_path_var.set(file_path)
                
                # Resmi önizle
                try:
                    img = Image.open(file_path)
                    img = img.resize((150, 150), Image.LANCZOS)
                    photo = ImageTk.PhotoImage(img)
                    
                    image_preview_label.config(image=photo)
                    image_preview_label.image = photo  # Referansı tut
                except Exception as e:
                    print(f"Resim önizlenirken hata: {e}")
                    image_preview_label.config(image="", text="Resim yüklenemedi")
        
        image_btn = tk.Button(
            image_frame,
            text=self.texts["browse"],
            command=browse_image_dialog,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 10),
            relief=tk.FLAT
        )
        image_btn.pack(side=tk.LEFT, padx=5)
        
        # Resim önizlemesi
        image_preview_frame = tk.Frame(form_frame, bg=self.colors["card_bg"])
        image_preview_frame.grid(row=7, column=0, columnspan=2, pady=10)
        
        tk.Label(image_preview_frame, text="Resim Önizleme", font=("Arial", 12, "bold"), bg=self.colors["card_bg"], fg=self.colors["fg"]).pack(pady=5)
        
        image_preview_label = tk.Label(image_preview_frame, bg=self.colors["card_bg"], width=20, height=10)
        image_preview_label.pack(pady=10)
        
        # Mevcut resmi göster
        if image_path and os.path.exists(image_path):
            try:
                img = Image.open(image_path)
                img = img.resize((150, 150), Image.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                
                image_preview_label.config(image=photo)
                image_preview_label.image = photo  # Referansı tut
            except Exception as e:
                print(f"Resim gösterilirken hata: {e}")
        
        # Ses dosyası
        tk.Label(form_frame, text="Ses Dosyası:", font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=8, column=0, sticky="w", padx=20, pady=10)
        audio_path_var = tk.StringVar(value=audio_path if audio_path else "")
        audio_frame = tk.Frame(form_frame, bg=self.colors["card_bg"])
        audio_frame.grid(row=8, column=1, padx=20, pady=10, sticky="w")
        
        audio_entry = tk.Entry(audio_frame, textvariable=audio_path_var, font=("Arial", 10), width=30)
        audio_entry.pack(side=tk.LEFT)
        
        def browse_audio_dialog():
            file_path = filedialog.askopenfilename(
                title="Ses Dosyası Seç",
                filetypes=[("Audio files", "*.mp3 *.wav *.ogg")]
            )
            
            if file_path:
                audio_path_var.set(file_path)
        
        audio_btn = tk.Button(
            audio_frame,
            text=self.texts["browse"],
            command=browse_audio_dialog,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 10),
            relief=tk.FLAT
        )
        audio_btn.pack(side=tk.LEFT, padx=5)
        
        # Ses durumu
        audio_status_label = tk.Label(form_frame, text="", font=("Arial", 10), bg=self.colors["card_bg"], fg=self.colors["fg"])
        audio_status_label.grid(row=9, column=0, columnspan=2, pady=5)
        
        # Butonlar
        button_frame = tk.Frame(dialog, bg=self.colors["bg"])
        button_frame.pack(fill=tk.X, padx=20, pady=10)
        
        def save_word_changes():
            new_turkish = turkish_var.get().strip()
            new_arabic = arabic_var.get().strip()
            new_category_name = category_var.get()
            new_category = new_category_var.get().strip()
            new_difficulty = difficulty_var.get()
            new_notes = notes_text.get(1.0, tk.END).strip()
            new_image_path = image_path_var.get()
            new_audio_path = audio_path_var.get()
            
            if not new_turkish or not new_arabic:
                messagebox.showwarning("Uyarı", "Lütfen Türkçe ve Arapça kelimeleri girin!")
                return
                
            # Kategori işlemleri
            if new_category:
                new_category_id = self.create_category(new_category)
            elif new_category_name:
                self.cursor.execute("SELECT id FROM categories WHERE name=?", (new_category_name,))
                result = self.cursor.fetchone()
                if result:
                    new_category_id = result[0]
                else:
                    messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin veya yeni kategori oluşturun!")
                    return
            else:
                new_category_id = None
                
            # Resim işlemleri
            final_image_path = image_path  # Varsayılan olarak mevcut resim yolunu koru
            
            if new_image_path and new_image_path != image_path:
                try:
                    # Resim dosyasını kopyala
                    image_filename = f"{self.sanitize_filename(new_turkish)}.jpg"
                    final_image_path = os.path.join("resimler", image_filename)
                    img = Image.open(new_image_path)
                    if img.mode == "RGBA":
                        img = img.convert("RGB")
                    img.save(final_image_path)
                except Exception as e:
                    print(f"Resim kaydedilirken hata: {e}")
                    messagebox.showwarning("Uyarı", f"Resim kaydedilemedi: {e}")
                    
            # Ses dosyası işlemleri
            final_audio_path = audio_path  # Varsayılan olarak mevcut ses yolunu koru
            
            if new_audio_path and new_audio_path != audio_path:
                try:
                    # Ses dosyasını kopyala
                    audio_filename = f"{self.sanitize_filename(new_turkish)}.mp3"
                    final_audio_path = os.path.join("sesler", audio_filename)
                    
                    # Eğer dosya zaten varsa, üzerine yazmayı dene
                    if os.path.exists(final_audio_path):
                        try:
                            os.remove(final_audio_path)
                        except PermissionError:
                            # Dosya kullanımda ise, alternatif bir isim dene
                            base_name = os.path.splitext(audio_filename)[0]
                            audio_filename = f"{base_name}_{int(time.time())}.mp3"
                            final_audio_path = os.path.join("sesler", audio_filename)
                            
                    import shutil
                    shutil.copy2(new_audio_path, final_audio_path)
                    
                    audio_status_label.config(text="Ses dosyası güncellendi", fg="green")
                except Exception as e:
                    print(f"Ses dosyası güncellenirken hata: {e}")
                    audio_status_label.config(text=f"Ses dosyası güncellenemedi: {e}", fg="red")
            elif not new_audio_path and new_arabic != arabic:
                # Arapça kelime değiştiyse, yeni ses dosyası oluştur
                try:
                    audio_filename = f"{self.sanitize_filename(new_turkish)}.mp3"
                    final_audio_path = os.path.join("sesler", audio_filename)
                    
                    # Eğer dosya zaten varsa, üzerine yazmayı dene
                    if os.path.exists(final_audio_path):
                        try:
                            os.remove(final_audio_path)
                        except PermissionError:
                            # Dosya kullanımda ise, alternatif bir isim dene
                            base_name = os.path.splitext(audio_filename)[0]
                            audio_filename = f"{base_name}_{int(time.time())}.mp3"
                            final_audio_path = os.path.join("sesler", audio_filename)
                            
                    tts = gTTS(text=new_arabic, lang='ar')
                    tts.save(final_audio_path)
                    
                    audio_status_label.config(text="Ses dosyası oluşturuldu", fg="green")
                except Exception as e:
                    print(f"Ses dosyası oluşturulurken hata: {e}")
                    audio_status_label.config(text=f"Ses dosyası oluşturulamadı: {e}", fg="red")
                    
            try:
                # Kelimeyi güncelle
                self.cursor.execute('''
                UPDATE words 
                SET turkish = ?, arabic = ?, image_path = ?, audio_path = ?, category_id = ?, difficulty = ?, notes = ?
                WHERE id = ?
                ''', (new_turkish, new_arabic, final_image_path, final_audio_path, new_category_id, new_difficulty, new_notes, word_id))
                
                self.conn.commit()
                
                messagebox.showinfo("Başarılı", self.texts["word_updated"])
                
                # Dialogu kapat
                dialog.destroy()
                
                # Tabloyu güncelle
                self.load_words_table()
                
                # Verileri yeniden yükle
                self.load_data()
                
            except Exception as e:
                messagebox.showerror("Hata", f"Kelime güncellenirken hata: {e}")
                
        save_btn = tk.Button(
            button_frame,
            text=self.texts["save"],
            command=save_word_changes,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        save_btn.pack(side=tk.RIGHT, padx=5)
        
        cancel_btn = tk.Button(
            button_frame,
            text="İptal",
            command=dialog.destroy,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        cancel_btn.pack(side=tk.RIGHT, padx=5)
        
    def delete_selected_word(self):
        selected_item = self.words_tree.selection()
        if not selected_item:
            messagebox.showwarning("Uyarı", "Lütfen silmek için bir kelime seçin!")
            return
            
        word_id = self.words_tree.item(selected_item[0])['values'][0]
        turkish = self.words_tree.item(selected_item[0])['values'][1]
        
        if messagebox.askyesno("Onay", f"'{turkish}' kelimesini silmek istediğinizden emin misiniz?"):
            try:
                # Kelime ilerlemesini sil
                self.cursor.execute("DELETE FROM word_progress WHERE word_id=?", (word_id,))
                
                # Kelimeyi sil
                self.cursor.execute("DELETE FROM words WHERE id=?", (word_id,))
                
                self.conn.commit()
                
                messagebox.showinfo("Başarılı", "Kelime başarıyla silindi!")
                
                # Tabloyu güncelle
                self.load_words_table()
                
                # Verileri yeniden yükle
                self.load_data()
                
            except Exception as e:
                messagebox.showerror("Hata", f"Kelime silinirken hata: {e}")
                
    def show_sentences_management(self):
        # Filtreleme çerçevesi
        filter_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        filter_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(
            filter_frame,
            text="Kategori:",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(side=tk.LEFT, padx=10)
        
        self.sentences_filter_category_var = tk.StringVar()
        self.sentences_filter_category_combobox = ttk.Combobox(
            filter_frame,
            textvariable=self.sentences_filter_category_var,
            font=("Arial", 12),
            width=20
        )
        self.sentences_filter_category_combobox.pack(side=tk.LEFT, padx=10)
        
        # Kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = ["Tümü"] + [row[0] for row in self.cursor.fetchall()]
            self.sentences_filter_category_combobox['values'] = categories
            self.sentences_filter_category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Ara butonu
        search_btn = tk.Button(
            filter_frame,
            text="Ara",
            command=self.search_sentences,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        search_btn.pack(side=tk.LEFT, padx=10)
        
        # Cümleler tablosu
        table_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        table_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(table_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Treeview
        self.sentences_tree = ttk.Treeview(
            table_frame,
            columns=("id", "turkish", "arabic", "category", "difficulty"),
            show="headings",
            yscrollcommand=scrollbar.set
        )
        self.sentences_tree.pack(fill=tk.BOTH, expand=True)
        
        scrollbar.config(command=self.sentences_tree.yview)
        
        # Sütunları ayarla
        self.sentences_tree.heading("id", text="ID")
        self.sentences_tree.heading("turkish", text="Türkçe")
        self.sentences_tree.heading("arabic", text="Arapça")
        self.sentences_tree.heading("category", text="Kategori")
        self.sentences_tree.heading("difficulty", text="Zorluk")
        
        self.sentences_tree.column("id", width=50)
        self.sentences_tree.column("turkish", width=200)
        self.sentences_tree.column("arabic", width=200)
        self.sentences_tree.column("category", width=150)
        self.sentences_tree.column("difficulty", width=80)
        
        # Çift tıklama olayı
        self.sentences_tree.bind("<Double-1>", self.edit_sentence)
        
        # Butonlar
        buttons_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        buttons_frame.pack(fill=tk.X, padx=20, pady=10)
        
        edit_btn = tk.Button(
            buttons_frame,
            text=self.texts["edit_sentence"],
            command=self.edit_selected_sentence,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        edit_btn.pack(side=tk.LEFT, padx=5)
        
        delete_btn = tk.Button(
            buttons_frame,
            text="Sil",
            command=self.delete_selected_sentence,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        delete_btn.pack(side=tk.LEFT, padx=5)
        
        # Cümleleri yükle
        self.load_sentences_table()
        
    def load_sentences_table(self):
        # Tabloyu temizle
        for item in self.sentences_tree.get_children():
            self.sentences_tree.delete(item)
            
        # Cümleleri getir
        category_name = self.sentences_filter_category_var.get()
        
        if category_name == "Tümü":
            self.cursor.execute('''
            SELECT s.id, s.turkish, s.arabic, c.name, s.difficulty 
            FROM sentences s
            LEFT JOIN categories c ON s.category_id = c.id
            ORDER BY s.turkish
            ''')
        else:
            self.cursor.execute('''
            SELECT s.id, s.turkish, s.arabic, c.name, s.difficulty 
            FROM sentences s
            LEFT JOIN categories c ON s.category_id = c.id
            WHERE c.name = ?
            ORDER BY s.turkish
            ''', (category_name,))
            
        sentences = self.cursor.fetchall()
        
        # Tabloya ekle
        for sentence in sentences:
            self.sentences_tree.insert("", tk.END, values=sentence)
            
    def search_sentences(self):
        self.load_sentences_table()
        
    def edit_selected_sentence(self):
        selected_item = self.sentences_tree.selection()
        if not selected_item:
            messagebox.showwarning("Uyarı", "Lütfen düzenlemek için bir kelime seçin!")
            return
            
        sentence_id = self.sentences_tree.item(selected_item[0])['values'][0]
        self.edit_sentence_dialog(sentence_id)
        
    def edit_sentence(self, event):
        selected_item = self.sentences_tree.selection()
        if not selected_item:
            return
            
        sentence_id = self.sentences_tree.item(selected_item[0])['values'][0]
        self.edit_sentence_dialog(sentence_id)
        
    def edit_sentence_dialog(self, sentence_id):
        # Cümle bilgilerini al
        self.cursor.execute("SELECT * FROM sentences WHERE id=?", (sentence_id,))
        sentence = self.cursor.fetchone()
        
        if not sentence:
            messagebox.showerror("Hata", "Cümle bulunamadı!")
            return
            
        sentence_id, turkish, arabic, audio_path, category_id, difficulty, created_at = sentence
        
        # Kategori adını al
        category_name = ""
        if category_id:
            self.cursor.execute("SELECT name FROM categories WHERE id=?", (category_id,))
            category_result = self.cursor.fetchone()
            if category_result:
                category_name = category_result[0]
        
        # Düzenleme penceresi
        dialog = tk.Toplevel(self.root)
        dialog.title(self.texts["edit_sentence"])
        dialog.geometry("600x500")
        dialog.configure(bg=self.colors["bg"])
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Başlık
        tk.Label(
            dialog,
            text=self.texts["edit_sentence"],
            font=("Arial", 16, "bold"),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        ).pack(pady=10)
        
        # Form çerçevesi
        form_frame = tk.Frame(dialog, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        form_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Türkçe cümle
        tk.Label(form_frame, text=self.texts["turkish_sentence"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=0, column=0, sticky="w", padx=20, pady=10)
        turkish_var = tk.StringVar(value=turkish)
        turkish_entry = tk.Entry(form_frame, textvariable=turkish_var, font=("Arial", 12), width=40)
        turkish_entry.grid(row=0, column=1, padx=20, pady=10)
        
        # Arapça cümle
        tk.Label(form_frame, text=self.texts["arabic_sentence"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=1, column=0, sticky="w", padx=20, pady=10)
        arabic_var = tk.StringVar(value=arabic)
        arabic_entry = tk.Entry(form_frame, textvariable=arabic_var, font=("Arial", 12), width=40)
        arabic_entry.grid(row=1, column=1, padx=20, pady=10)
        
        # Kategori seçimi
        tk.Label(form_frame, text=self.texts["category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=2, column=0, sticky="w", padx=20, pady=10)
        
        category_var = tk.StringVar(value=category_name)
        category_combobox = ttk.Combobox(form_frame, textvariable=category_var, font=("Arial", 10), width=37)
        category_combobox.grid(row=2, column=1, padx=20, pady=10, sticky="w")
        
        # Mevcut kategorileri yükle
        try:
            self.cursor.execute("SELECT name FROM categories ORDER BY name")
            categories = [row[0] for row in self.cursor.fetchall()]
            category_combobox['values'] = categories
            if categories and category_name in categories:
                category_combobox.current(categories.index(category_name))
            elif categories:
                category_combobox.current(0)
        except Exception as e:
            print(f"Kategoriler yüklenirken hata: {e}")
        
        # Yeni kategori oluşturma
        tk.Label(form_frame, text=self.texts["new_category"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=3, column=0, sticky="w", padx=20, pady=10)
        new_category_var = tk.StringVar()
        new_category_entry = tk.Entry(form_frame, textvariable=new_category_var, font=("Arial", 12), width=40)
        new_category_entry.grid(row=3, column=1, padx=20, pady=10)
        
        # Zorluk seviyesi
        tk.Label(form_frame, text=self.texts["difficulty"], font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=4, column=0, sticky="w", padx=20, pady=10)
        difficulty_var = tk.IntVar(value=difficulty)
        difficulty_frame = tk.Frame(form_frame, bg=self.colors["card_bg"])
        difficulty_frame.grid(row=4, column=1, padx=20, pady=10, sticky="w")
        
        for i in range(1, 6):
            tk.Radiobutton(
                difficulty_frame,
                text=str(i),
                variable=difficulty_var,
                value=i,
                bg=self.colors["card_bg"],
                fg=self.colors["fg"]
            ).pack(side=tk.LEFT, padx=5)
        
        # Ses dosyası
        tk.Label(form_frame, text="Ses Dosyası:", font=("Arial", 12), bg=self.colors["card_bg"], fg=self.colors["fg"]).grid(row=5, column=0, sticky="w", padx=20, pady=10)
        audio_path_var = tk.StringVar(value=audio_path if audio_path else "")
        audio_frame = tk.Frame(form_frame, bg=self.colors["card_bg"])
        audio_frame.grid(row=5, column=1, padx=20, pady=10, sticky="w")
        
        audio_entry = tk.Entry(audio_frame, textvariable=audio_path_var, font=("Arial", 10), width=30)
        audio_entry.pack(side=tk.LEFT)
        
        def browse_audio_dialog():
            file_path = filedialog.askopenfilename(
                title="Ses Dosyası Seç",
                filetypes=[("Audio files", "*.mp3 *.wav *.ogg")]
            )
            
            if file_path:
                audio_path_var.set(file_path)
        
        audio_btn = tk.Button(
            audio_frame,
            text=self.texts["browse"],
            command=browse_audio_dialog,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 10),
            relief=tk.FLAT
        )
        audio_btn.pack(side=tk.LEFT, padx=5)
        
        # Ses durumu
        audio_status_label = tk.Label(form_frame, text="", font=("Arial", 10), bg=self.colors["card_bg"], fg=self.colors["fg"])
        audio_status_label.grid(row=6, column=0, columnspan=2, pady=5)
        
        # Butonlar
        button_frame = tk.Frame(dialog, bg=self.colors["bg"])
        button_frame.pack(fill=tk.X, padx=20, pady=10)
        
        def save_sentence_changes():
            new_turkish = turkish_var.get().strip()
            new_arabic = arabic_var.get().strip()
            new_category_name = category_var.get()
            new_category = new_category_var.get().strip()
            new_difficulty = difficulty_var.get()
            new_audio_path = audio_path_var.get()
            
            if not new_turkish or not new_arabic:
                messagebox.showwarning("Uyarı", "Lütfen Türkçe ve Arapça cümleleri girin!")
                return
                
            # Kategori işlemleri
            if new_category:
                new_category_id = self.create_category(new_category)
            elif new_category_name:
                self.cursor.execute("SELECT id FROM categories WHERE name=?", (new_category_name,))
                result = self.cursor.fetchone()
                if result:
                    new_category_id = result[0]
                else:
                    messagebox.showwarning("Uyarı", "Geçerli bir kategori seçin veya yeni kategori oluşturun!")
                    return
            else:
                new_category_id = None
                
            # Ses dosyası işlemleri
            final_audio_path = audio_path  # Varsayılan olarak mevcut ses yolunu koru
            
            if new_audio_path and new_audio_path != audio_path:
                try:
                    # Ses dosyasını kopyala
                    audio_filename = f"{self.sanitize_filename(new_turkish[:20])}.mp3"
                    final_audio_path = os.path.join("sesler", audio_filename)
                    
                    # Eğer dosya zaten varsa, üzerine yazmayı dene
                    if os.path.exists(final_audio_path):
                        try:
                            os.remove(final_audio_path)
                        except PermissionError:
                            # Dosya kullanımda ise, alternatif bir isim dene
                            base_name = os.path.splitext(audio_filename)[0]
                            audio_filename = f"{base_name}_{int(time.time())}.mp3"
                            final_audio_path = os.path.join("sesler", audio_filename)
                            
                    import shutil
                    shutil.copy2(new_audio_path, final_audio_path)
                    
                    audio_status_label.config(text="Ses dosyası güncellendi", fg="green")
                except Exception as e:
                    print(f"Ses dosyası güncellenirken hata: {e}")
                    audio_status_label.config(text=f"Ses dosyası güncellenemedi: {e}", fg="red")
            elif not new_audio_path and new_arabic != arabic:
                # Arapça cümle değiştiyse, yeni ses dosyası oluştur
                try:
                    audio_filename = f"{self.sanitize_filename(new_turkish[:20])}.mp3"
                    final_audio_path = os.path.join("sesler", audio_filename)
                    
                    # Eğer dosya zaten varsa, üzerine yazmayı dene
                    if os.path.exists(final_audio_path):
                        try:
                            os.remove(final_audio_path)
                        except PermissionError:
                            # Dosya kullanımda ise, alternatif bir isim dene
                            base_name = os.path.splitext(audio_filename)[0]
                            audio_filename = f"{base_name}_{int(time.time())}.mp3"
                            final_audio_path = os.path.join("sesler", audio_filename)
                            
                    tts = gTTS(text=new_arabic, lang='ar')
                    tts.save(final_audio_path)
                    
                    audio_status_label.config(text="Ses dosyası oluşturuldu", fg="green")
                except Exception as e:
                    print(f"Ses dosyası oluşturulurken hata: {e}")
                    audio_status_label.config(text=f"Ses dosyası oluşturulamadı: {e}", fg="red")
                    
            try:
                # Cümleyi güncelle
                self.cursor.execute('''
                UPDATE sentences 
                SET turkish = ?, arabic = ?, audio_path = ?, category_id = ?, difficulty = ?
                WHERE id = ?
                ''', (new_turkish, new_arabic, final_audio_path, new_category_id, new_difficulty, sentence_id))
                
                self.conn.commit()
                
                messagebox.showinfo("Başarılı", self.texts["sentence_updated"])
                
                # Dialogu kapat
                dialog.destroy()
                
                # Tabloyu güncelle
                self.load_sentences_table()
                
                # Verileri yeniden yükle
                self.load_data()
                
            except Exception as e:
                messagebox.showerror("Hata", f"Cümle güncellenirken hata: {e}")
                
        save_btn = tk.Button(
            button_frame,
            text=self.texts["save"],
            command=save_sentence_changes,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        save_btn.pack(side=tk.RIGHT, padx=5)
        
        cancel_btn = tk.Button(
            button_frame,
            text="İptal",
            command=dialog.destroy,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        cancel_btn.pack(side=tk.RIGHT, padx=5)
        
    def delete_selected_sentence(self):
        selected_item = self.sentences_tree.selection()
        if not selected_item:
            messagebox.showwarning("Uyarı", "Lütfen silmek için bir cümle seçin!")
            return
            
        sentence_id = self.sentences_tree.item(selected_item[0])['values'][0]
        turkish = self.sentences_tree.item(selected_item[0])['values'][1]
        
        if messagebox.askyesno("Onay", f"'{turkish}' cümlesini silmek istediğinizden emin misiniz?"):
            try:
                # Cümleyi sil
                self.cursor.execute("DELETE FROM sentences WHERE id=?", (sentence_id,))
                
                self.conn.commit()
                
                messagebox.showinfo("Başarılı", "Cümle başarıyla silindi!")
                
                # Tabloyu güncelle
                self.load_sentences_table()
                
                # Verileri yeniden yükle
                self.load_data()
                
            except Exception as e:
                messagebox.showerror("Hata", f"Cümle silinirken hata: {e}")
                
    def show_categories_management(self):
        # Kategoriler tablosu
        table_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        table_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(table_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Treeview
        self.categories_tree = ttk.Treeview(
            table_frame,
            columns=("id", "name", "word_count", "sentence_count"),
            show="headings",
            yscrollcommand=scrollbar.set
        )
        self.categories_tree.pack(fill=tk.BOTH, expand=True)
        
        scrollbar.config(command=self.categories_tree.yview)
        
        # Sütunları ayarla
        self.categories_tree.heading("id", text="ID")
        self.categories_tree.heading("name", text="Kategori Adı")
        self.categories_tree.heading("word_count", text="Kelime Sayısı")
        self.categories_tree.heading("sentence_count", text="Cümle Sayısı")
        
        self.categories_tree.column("id", width=50)
        self.categories_tree.column("name", width=200)
        self.categories_tree.column("word_count", width=100)
        self.categories_tree.column("sentence_count", width=100)
        
        # Butonlar
        buttons_frame = tk.Frame(self.management_frame, bg=self.colors["card_bg"])
        buttons_frame.pack(fill=tk.X, padx=20, pady=10)
        
        delete_btn = tk.Button(
            buttons_frame,
            text=self.texts["delete_category"],
            command=self.delete_selected_category,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        delete_btn.pack(side=tk.LEFT, padx=5)
        
        # Kategorileri yükle
        self.load_categories_table()
        
    def load_categories_table(self):
        # Tabloyu temizle
        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)
            
        # Kategorileri getir
        self.cursor.execute("SELECT * FROM categories ORDER BY name")
        categories = self.cursor.fetchall()
        
        # Tabloya ekle
        for category in categories:
            category_id, name, created_at = category
            
            # Kelime sayısını al
            self.cursor.execute("SELECT COUNT(*) FROM words WHERE category_id=?", (category_id,))
            word_count = self.cursor.fetchone()[0]
            
            # Cümle sayısını al
            self.cursor.execute("SELECT COUNT(*) FROM sentences WHERE category_id=?", (category_id,))
            sentence_count = self.cursor.fetchone()[0]
            
            self.categories_tree.insert("", tk.END, values=(category_id, name, word_count, sentence_count))
            
    def delete_selected_category(self):
        selected_item = self.categories_tree.selection()
        if not selected_item:
            messagebox.showwarning("Uyarı", "Lütfen silmek için bir kategori seçin!")
            return
            
        category_id = self.categories_tree.item(selected_item[0])['values'][0]
        category_name = self.categories_tree.item(selected_item[0])['values'][1]
        
        success, message = self.delete_category(category_id)
        
        if success:
            messagebox.showinfo("Başarılı", message)
            # Tabloyu güncelle
            self.load_categories_table()
        else:
            messagebox.showwarning("Hata", message)
            
    def show_stats(self):
        self.clear_frame()
        self.current_page = "statistics"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["statistics"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # İstatistik türleri
        stats_types_frame = tk.Frame(self.root, bg=self.colors["bg"])
        stats_types_frame.pack(fill=tk.X, padx=20, pady=10)
        
        general_stats_btn = tk.Button(
            stats_types_frame,
            text=self.texts["general_stats"],
            command=lambda: self.show_stats_tab("general"),
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        general_stats_btn.pack(side=tk.LEFT, padx=5)
        
        daily_stats_btn = tk.Button(
            stats_types_frame,
            text=self.texts["daily_stats"],
            command=lambda: self.show_stats_tab("daily"),
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        daily_stats_btn.pack(side=tk.LEFT, padx=5)
        
        weekly_stats_btn = tk.Button(
            stats_types_frame,
            text=self.texts["weekly_stats"],
            command=lambda: self.show_stats_tab("weekly"),
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        weekly_stats_btn.pack(side=tk.LEFT, padx=5)
        
        category_stats_btn = tk.Button(
            stats_types_frame,
            text=self.texts["category_stats"],
            command=lambda: self.show_stats_tab("category"),
            bg="#95a5a6",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=5
        )
        category_stats_btn.pack(side=tk.LEFT, padx=5)
        
        # İstatistik alanı
        self.stats_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        self.stats_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Genel istatistikleri göster
        self.show_stats_tab("general")
        
    def show_stats_tab(self, tab_name):
        # İstatistik alanını temizle
        for widget in self.stats_frame.winfo_children():
            widget.destroy()
            
        # Sekme butonlarını güncelle
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Frame) and widget == self.root.winfo_children()[2]:  # stats_types_frame
                for btn in widget.winfo_children():
                    if isinstance(btn, tk.Button):
                        if tab_name == "general" and btn["text"] == self.texts["general_stats"]:
                            btn.config(bg=self.colors["button_bg"])
                        elif tab_name == "daily" and btn["text"] == self.texts["daily_stats"]:
                            btn.config(bg=self.colors["button_bg"])
                        elif tab_name == "weekly" and btn["text"] == self.texts["weekly_stats"]:
                            btn.config(bg=self.colors["button_bg"])
                        elif tab_name == "category" and btn["text"] == self.texts["category_stats"]:
                            btn.config(bg=self.colors["button_bg"])
                        else:
                            btn.config(bg="#95a5a6")
        
        if tab_name == "general":
            self.show_general_stats()
        elif tab_name == "daily":
            self.show_daily_stats()
        elif tab_name == "weekly":
            self.show_weekly_stats()
        elif tab_name == "category":
            self.show_category_stats()
            
    def show_general_stats(self):
        # Kullanıcı profil bilgilerini al
        self.cursor.execute("SELECT name, level, experience FROM user_profile WHERE id=?", (self.current_profile_id,))
        user_profile = self.cursor.fetchone()
        
        if not user_profile:
            tk.Label(
                self.stats_frame,
                text="Profil bulunamadı!",
                font=("Arial", 14),
                bg=self.colors["card_bg"],
                fg=self.colors["fg"]
            ).pack(expand=True)
            return
            
        user_name, user_level, user_exp = user_profile
        
        # Genel istatistikler çerçevesi
        stats_container = tk.Frame(self.stats_frame, bg=self.colors["card_bg"])
        stats_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Profil bilgileri
        profile_frame = tk.LabelFrame(
            stats_container,
            text="Profil Bilgileri",
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        profile_frame.pack(fill=tk.X, padx=10, pady=10)
        
        tk.Label(
            profile_frame,
            text=f"{self.texts['profile']}: {user_name}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        tk.Label(
            profile_frame,
            text=f"{self.texts['level']}: {user_level}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        tk.Label(
            profile_frame,
            text=f"{self.texts['experience']}: {user_exp}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        # Genel istatistikler
        general_frame = tk.LabelFrame(
            stats_container,
            text=self.texts["general_stats"],
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        general_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Toplam süre
        total_minutes = self.stats['total_time'] // 60
        total_seconds = self.stats['total_time'] % 60
        tk.Label(
            general_frame,
            text=f"{self.texts['total_time']}: {total_minutes}:{total_seconds:02d}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        # Doğru ve yanlış sayıları
        tk.Label(
            general_frame,
            text=f"Doğru Cevaplar: {self.stats['correct']}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["correct_bg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        tk.Label(
            general_frame,
            text=f"Yanlış Cevaplar: {self.stats['wrong']}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["wrong_bg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        # Başarı oranı
        if self.stats['correct'] + self.stats['wrong'] > 0:
            success_rate = (self.stats['correct'] / (self.stats['correct'] + self.stats['wrong'])) * 100
            tk.Label(
                general_frame,
                text=f"Başarı Oranı: {success_rate:.1f}%",
                font=("Arial", 12, "bold"),
                bg=self.colors["card_bg"],
                fg=self.colors["accent"]
            ).pack(anchor="w", padx=10, pady=5)
        
        # Öğrenilen kelimeler
        self.cursor.execute("SELECT COUNT(*) FROM words")
        total_words = self.cursor.fetchone()[0]
        
        self.cursor.execute("SELECT COUNT(DISTINCT word_id) FROM word_progress WHERE correct_count > 0 AND profile_id=?", (self.current_profile_id,))
        learned_words = self.cursor.fetchone()[0]
        
        tk.Label(
            general_frame,
            text=f"Toplam Kelimeler: {total_words}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        tk.Label(
            general_frame,
            text=f"Çalışılan Kelimeler: {learned_words}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        # Öğrenilen cümleler
        self.cursor.execute("SELECT COUNT(*) FROM sentences")
        total_sentences = self.cursor.fetchone()[0]
        
        tk.Label(
            general_frame,
            text=f"Toplam Cümleler: {total_sentences}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        ).pack(anchor="w", padx=10, pady=5)
        
        # Son sınavlar
        exam_frame = tk.LabelFrame(
            stats_container,
            text=self.texts["last_exams"],
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        exam_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(exam_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Treeview
        exam_tree = ttk.Treeview(
            exam_frame,
            columns=("type", "category", "score", "total", "date"),
            show="headings",
            yscrollcommand=scrollbar.set
        )
        exam_tree.pack(fill=tk.BOTH, expand=True)
        
        scrollbar.config(command=exam_tree.yview)
        
        # Sütunları ayarla
        exam_tree.heading("type", text=self.texts["exam_type"])
        exam_tree.heading("category", text="Kategori")
        exam_tree.heading("score", text=self.texts["exam_score"])
        exam_tree.heading("total", text="Toplam Soru")
        exam_tree.heading("date", text=self.texts["exam_date"])
        
        exam_tree.column("type", width=100)
        exam_tree.column("category", width=150)
        exam_tree.column("score", width=80)
        exam_tree.column("total", width=80)
        exam_tree.column("date", width=150)
        
        # Son sınavları getir
        self.cursor.execute('''
        SELECT e.exam_type, c.name, e.score, e.total_questions, e.date
        FROM exam_results e
        LEFT JOIN categories c ON e.category_id = c.id
        WHERE e.profile_id = ?
        ORDER BY e.date DESC
        LIMIT 10
        ''', (self.current_profile_id,))
        
        exams = self.cursor.fetchall()
        
        if not exams:
            exam_tree.insert("", tk.END, values=("-", "Henüz sınav yapılmamış", "-", "-", "-"))
        else:
            for exam in exams:
                exam_type, category, score, total, date = exam
                
                # Tarih formatını düzenle
                try:
                    exam_date = datetime.strptime(date, "%Y-%m-%d %H:%M:%S.%f")
                except ValueError:
                    exam_date = datetime.strptime(date, "%Y-%m-%d %H:%M:%S")
                formatted_date = exam_date.strftime("%d.%m.%Y %H:%M")
                
                exam_tree.insert("", tk.END, values=(exam_type, category if category else "-", f"{score}/{total}", total, formatted_date))
                
    def show_daily_stats(self):
        # Günlük istatistikler çerçevesi
        stats_container = tk.Frame(self.stats_frame, bg=self.colors["card_bg"])
        stats_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Grafik alanı
        fig, ax = plt.subplots(figsize=(10, 6), facecolor=self.colors["card_bg"])
        ax.set_facecolor(self.colors["card_bg"])
        
        # Son 7 günün verilerini al
        dates = []
        correct_counts = []
        wrong_counts = []
        
        for i in range(6, -1, -1):
            date = datetime.now() - timedelta(days=i)
            date_str = date.strftime("%Y-%m-%d")
            dates.append(date.strftime("%d.%m"))
            
            # Bu gün için doğru ve yanlış sayılarını al
            correct = 0
            wrong = 0
            
            # Sınav sonuçlarından al
            self.cursor.execute('''
            SELECT score, total_questions FROM exam_results 
            WHERE profile_id = ? AND date >= ? AND date < ?
            ''', (self.current_profile_id, date_str, (date + timedelta(days=1)).strftime("%Y-%m-%d")))
            
            exams = self.cursor.fetchall()
            for exam in exams:
                score, total = exam
                correct += score
                wrong += total - score
                
            correct_counts.append(correct)
            wrong_counts.append(wrong)
        
        # Grafik oluştur
        x = np.arange(len(dates))
        width = 0.35
        
        bars1 = ax.bar(x - width/2, correct_counts, width, label='Doğru', color=self.colors["correct_bg"])
        bars2 = ax.bar(x + width/2, wrong_counts, width, label='Yanlış', color=self.colors["wrong_bg"])
        
        ax.set_title('Son 7 Günün Performansı', fontsize=14, color=self.colors["fg"])
        ax.set_xticks(x)
        ax.set_xticklabels(dates)
        ax.legend()
        
        ax.set_xlabel('Tarih', color=self.colors["fg"])
        ax.set_ylabel('Sayı', color=self.colors["fg"])
        
        ax.tick_params(axis='x', colors=self.colors["fg"])
        ax.tick_params(axis='y', colors=self.colors["fg"])
        
        # Grafiği Tkinter penceresine ekle
        canvas = FigureCanvasTkAgg(fig, master=stats_container)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Detaylı istatistikler
        details_frame = tk.Frame(stats_container, bg=self.colors["card_bg"])
        details_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Toplam doğru ve yanlış sayıları
        total_correct = sum(correct_counts)
        total_wrong = sum(wrong_counts)
        
        tk.Label(
            details_frame,
            text=f"Son 7 Gün Toplam Doğru: {total_correct}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["correct_bg"]
        ).pack(side=tk.LEFT, padx=20)
        
        tk.Label(
            details_frame,
            text=f"Son 7 Gün Toplam Yanlış: {total_wrong}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["wrong_bg"]
        ).pack(side=tk.LEFT, padx=20)
        
        if total_correct + total_wrong > 0:
            success_rate = (total_correct / (total_correct + total_wrong)) * 100
            tk.Label(
                details_frame,
                text=f"Son 7 Gün Başarı Oranı: {success_rate:.1f}%",
                font=("Arial", 12, "bold"),
                bg=self.colors["card_bg"],
                fg=self.colors["accent"]
            ).pack(side=tk.LEFT, padx=20)
            
    def show_weekly_stats(self):
        # Haftalık istatistikler çerçevesi
        stats_container = tk.Frame(self.stats_frame, bg=self.colors["card_bg"])
        stats_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Grafik alanı
        fig, ax = plt.subplots(figsize=(10, 6), facecolor=self.colors["card_bg"])
        ax.set_facecolor(self.colors["card_bg"])
        
        # Son 4 haftanın verilerini al
        weeks = []
        correct_counts = []
        wrong_counts = []
        
        for i in range(3, -1, -1):
            # Haftanın başlangıç ve bitiş tarihleri
            start_date = datetime.now() - timedelta(weeks=i+1, days=datetime.now().weekday())
            end_date = start_date + timedelta(days=6)
            
            week_str = f"{start_date.strftime('%d.%m')}-{end_date.strftime('%d.%m')}"
            weeks.append(week_str)
            
            # Bu hafta için doğru ve yanlış sayılarını al
            correct = 0
            wrong = 0
            
            # Sınav sonuçlarından al
            self.cursor.execute('''
            SELECT score, total_questions FROM exam_results 
            WHERE profile_id = ? AND date >= ? AND date <= ?
            ''', (self.current_profile_id, start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d")))
            
            exams = self.cursor.fetchall()
            for exam in exams:
                score, total = exam
                correct += score
                wrong += total - score
                
            correct_counts.append(correct)
            wrong_counts.append(wrong)
        
        # Grafik oluştur
        x = np.arange(len(weeks))
        width = 0.35
        
        bars1 = ax.bar(x - width/2, correct_counts, width, label='Doğru', color=self.colors["correct_bg"])
        bars2 = ax.bar(x + width/2, wrong_counts, width, label='Yanlış', color=self.colors["wrong_bg"])
        
        ax.set_title('Son 4 Haftanın Performansı', fontsize=14, color=self.colors["fg"])
        ax.set_xticks(x)
        ax.set_xticklabels(weeks)
        ax.legend()
        
        ax.set_xlabel('Hafta', color=self.colors["fg"])
        ax.set_ylabel('Sayı', color=self.colors["fg"])
        
        ax.tick_params(axis='x', colors=self.colors["fg"])
        ax.tick_params(axis='y', colors=self.colors["fg"])
        
        # Grafiği Tkinter penceresine ekle
        canvas = FigureCanvasTkAgg(fig, master=stats_container)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Detaylı istatistikler
        details_frame = tk.Frame(stats_container, bg=self.colors["card_bg"])
        details_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Toplam doğru ve yanlış sayıları
        total_correct = sum(correct_counts)
        total_wrong = sum(wrong_counts)
        
        tk.Label(
            details_frame,
            text=f"Son 4 Hafta Toplam Doğru: {total_correct}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["correct_bg"]
        ).pack(side=tk.LEFT, padx=20)
        
        tk.Label(
            details_frame,
            text=f"Son 4 Hafta Toplam Yanlış: {total_wrong}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["wrong_bg"]
        ).pack(side=tk.LEFT, padx=20)
        
        if total_correct + total_wrong > 0:
            success_rate = (total_correct / (total_correct + total_wrong)) * 100
            tk.Label(
                details_frame,
                text=f"Son 4 Hafta Başarı Oranı: {success_rate:.1f}%",
                font=("Arial", 12, "bold"),
                bg=self.colors["card_bg"],
                fg=self.colors["accent"]
            ).pack(side=tk.LEFT, padx=20)
            
    def show_category_stats(self):
        # Kategori istatistikleri çerçevesi
        stats_container = tk.Frame(self.stats_frame, bg=self.colors["card_bg"])
        stats_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Grafik alanı
        fig, ax = plt.subplots(figsize=(10, 6), facecolor=self.colors["card_bg"])
        ax.set_facecolor(self.colors["card_bg"])
        
        # Kategori verilerini al
        categories = []
        correct_counts = []
        wrong_counts = []
        
        self.cursor.execute("SELECT id, name FROM categories ORDER BY name")
        all_categories = self.cursor.fetchall()
        
        for category_id, category_name in all_categories:
            categories.append(category_name)
            
            # Bu kategori için doğru ve yanlış sayılarını al
            correct = 0
            wrong = 0
            
            # Sınav sonuçlarından al
            self.cursor.execute('''
            SELECT score, total_questions FROM exam_results 
            WHERE profile_id = ? AND category_id = ?
            ''', (self.current_profile_id, category_id))
            
            exams = self.cursor.fetchall()
            for exam in exams:
                score, total = exam
                correct += score
                wrong += total - score
                
            correct_counts.append(correct)
            wrong_counts.append(wrong)
        
        # Grafik oluştur
        x = np.arange(len(categories))
        width = 0.35
        
        bars1 = ax.bar(x - width/2, correct_counts, width, label='Doğru', color=self.colors["correct_bg"])
        bars2 = ax.bar(x + width/2, wrong_counts, width, label='Yanlış', color=self.colors["wrong_bg"])
        
        ax.set_title('Kategori Performansı', fontsize=14, color=self.colors["fg"])
        ax.set_xticks(x)
        ax.set_xticklabels(categories, rotation=45, ha='right')
        ax.legend()
        
        ax.set_xlabel('Kategori', color=self.colors["fg"])
        ax.set_ylabel('Sayı', color=self.colors["fg"])
        
        ax.tick_params(axis='x', colors=self.colors["fg"])
        ax.tick_params(axis='y', colors=self.colors["fg"])
        
        # Grafiği Tkinter penceresine ekle
        canvas = FigureCanvasTkAgg(fig, master=stats_container)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Detaylı istatistikler
        details_frame = tk.Frame(stats_container, bg=self.colors["card_bg"])
        details_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Toplam doğru ve yanlış sayıları
        total_correct = sum(correct_counts)
        total_wrong = sum(wrong_counts)
        
        tk.Label(
            details_frame,
            text=f"Toplam Doğru: {total_correct}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["correct_bg"]
        ).pack(side=tk.LEFT, padx=20)
        
        tk.Label(
            details_frame,
            text=f"Toplam Yanlış: {total_wrong}",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["wrong_bg"]
        ).pack(side=tk.LEFT, padx=20)
        
        if total_correct + total_wrong > 0:
            success_rate = (total_correct / (total_correct + total_wrong)) * 100
            tk.Label(
                details_frame,
                text=f"Genel Başarı Oranı: {success_rate:.1f}%",
                font=("Arial", 12, "bold"),
                bg=self.colors["card_bg"],
                fg=self.colors["accent"]
            ).pack(side=tk.LEFT, padx=20)
            
    def show_backup(self):
        self.clear_frame()
        self.current_page = "backup"
        
        top_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=60)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        back_btn = tk.Button(
            top_frame,
            text=self.texts["back"],
            command=self.create_main_page,
            bg=self.colors["wrong_bg"],
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.RAISED,
            bd=2,
            padx=15,
            pady=5
        )
        back_btn.pack(side=tk.LEFT, padx=20, pady=15)
        
        title_label = tk.Label(
            top_frame,
            text=self.texts["backup"],
            font=("Arial", 18, "bold"),
            bg=self.colors["title_bg"],
            fg=self.colors["title_fg"]
        )
        title_label.pack(side=tk.LEFT, padx=20)
        
        # Yedekleme alanı
        backup_frame = tk.Frame(self.root, bg=self.colors["card_bg"], relief=tk.RAISED, bd=2)
        backup_frame.pack(expand=True, fill=tk.BOTH, padx=50, pady=20)
        
        # Yedekleme seçenekleri
        options_frame = tk.Frame(backup_frame, bg=self.colors["card_bg"])
        options_frame.pack(fill=tk.X, padx=20, pady=20)
        
        # Veritabanı yedekleme
        db_frame = tk.LabelFrame(
            options_frame,
            text="Veritabanı Yedekleme",
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        db_frame.pack(fill=tk.X, padx=10, pady=10)
        
        db_info_label = tk.Label(
            db_frame,
            text="Veritabanını yedeklemek için aşağıdaki butona tıklayın.",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        db_info_label.pack(pady=10)
        
        db_backup_btn = tk.Button(
            db_frame,
            text="Veritabanını Yedekle",
            command=self.backup_database,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        db_backup_btn.pack(pady=10)
        
        # Medya dosyaları yedekleme
        media_frame = tk.LabelFrame(
            options_frame,
            text="Medya Dosyaları Yedekleme",
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        media_frame.pack(fill=tk.X, padx=10, pady=10)
        
        media_info_label = tk.Label(
            media_frame,
            text="Resim ve ses dosyalarını yedeklemek için aşağıdaki butona tıklayın.",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        media_info_label.pack(pady=10)
        
        media_backup_btn = tk.Button(
            media_frame,
            text="Medya Dosyalarını Yedekle",
            command=self.backup_media,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        media_backup_btn.pack(pady=10)
        
        # Tam yedekleme
        full_frame = tk.LabelFrame(
            options_frame,
            text="Tam Yedekleme",
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        full_frame.pack(fill=tk.X, padx=10, pady=10)
        
        full_info_label = tk.Label(
            full_frame,
            text="Tüm verileri (veritabanı ve medya dosyaları) yedeklemek için aşağıdaki butona tıklayın.",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        full_info_label.pack(pady=10)
        
        full_backup_btn = tk.Button(
            full_frame,
            text="Tam Yedekle",
            command=self.backup_all,
            bg="#27ae60",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        full_backup_btn.pack(pady=10)
        
        # Geri yükleme
        restore_frame = tk.LabelFrame(
            options_frame,
            text="Geri Yükleme",
            font=("Arial", 14, "bold"),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        restore_frame.pack(fill=tk.X, padx=10, pady=10)
        
        restore_info_label = tk.Label(
            restore_frame,
            text="Yedekten geri yüklemek için aşağıdaki butona tıklayın.",
            font=("Arial", 12),
            bg=self.colors["card_bg"],
            fg=self.colors["fg"]
        )
        restore_info_label.pack(pady=10)
        
        restore_btn = tk.Button(
            restore_frame,
            text="Yedekten Geri Yükle",
            command=self.restore_backup,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        )
        restore_btn.pack(pady=10)
        
    def backup_database(self):
        try:
            # Yedek dosyası için tarih ve saat oluştur
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = os.path.join("yedekler", f"arabic_learning_db_{timestamp}.db")
            
            # Veritabanı bağlantısını kapat
            self.conn.close()
            
            # Veritabanını kopyala
            import shutil
            shutil.copy2("arabic_learning.db", backup_file)
            
            # Veritabanı bağlantısını yeniden aç
            self.conn = sqlite3.connect('arabic_learning.db')
            self.cursor = self.conn.cursor()
            
            messagebox.showinfo("Başarılı", f"Veritabanı başarıyla yedeklendi:\n{backup_file}")
        except Exception as e:
            messagebox.showerror("Hata", f"Veritabanı yedeklenirken hata: {e}")
            
    def backup_media(self):
        try:
            # Yedek klasörü oluştur
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_folder = os.path.join("yedekler", f"media_{timestamp}")
            os.makedirs(backup_folder, exist_ok=True)
            
            # Resim klasörünü kopyala
            if os.path.exists("resimler"):
                shutil.copytree("resimler", os.path.join(backup_folder, "resimler"))
            
            # Ses klasörünü kopyala
            if os.path.exists("sesler"):
                shutil.copytree("sesler", os.path.join(backup_folder, "sesler"))
            
            messagebox.showinfo("Başarılı", f"Medya dosyaları başarıyla yedeklendi:\n{backup_folder}")
        except Exception as e:
            messagebox.showerror("Hata", f"Medya dosyaları yedeklenirken hata: {e}")
            
    def backup_all(self):
        try:
            # Yedek klasörü oluştur
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_folder = os.path.join("yedekler", f"full_backup_{timestamp}")
            os.makedirs(backup_folder, exist_ok=True)
            
            # Veritabanını kopyala
            shutil.copy2("arabic_learning.db", os.path.join(backup_folder, "arabic_learning.db"))
            
            # Resim klasörünü kopyala
            if os.path.exists("resimler"):
                shutil.copytree("resimler", os.path.join(backup_folder, "resimler"))
            
            # Ses klasörünü kopyala
            if os.path.exists("sesler"):
                shutil.copytree("sesler", os.path.join(backup_folder, "sesler"))
            
            # Ayar dosyasını kopyala
            if os.path.exists("settings.json"):
                shutil.copy2("settings.json", os.path.join(backup_folder, "settings.json"))
            
            messagebox.showinfo("Başarılı", f"Tüm veriler başarıyla yedeklendi:\n{backup_folder}")
        except Exception as e:
            messagebox.showerror("Hata", f"Tam yedekleme sırasında hata: {e}")
            
    def restore_backup(self):
        # Geri yükleme için dosya seç
        file_path = filedialog.askopenfilename(
            title="Yedek Dosyası Seç",
            filetypes=[("Yedek Dosyaları", "*.db"), ("Tüm Dosyalar", "*.*")]
        )
        
        if not file_path:
            return
            
        if messagebox.askyesno("Onay", "Seçilen yedek dosyasından geri yüklemek istediğinizden emin misiniz?\nMevcut verileriniz silinecektir!"):
            try:
                # Veritabanı bağlantısını kapat
                self.conn.close()
                
                # Yedek dosyasını kopyala
                shutil.copy2(file_path, "arabic_learning.db")
                
                # Veritabanı bağlantısını yeniden aç
                self.conn = sqlite3.connect('arabic_learning.db')
                self.cursor = self.conn.cursor
                
                # Veritabanını yeniden oluştur
                self.create_tables()
                self.migrate_database()
                
                # Verileri yeniden yükle
                self.load_data()
                
                messagebox.showinfo("Başarılı", "Yedekten geri yükleme tamamlandı!")
            except Exception as e:
                messagebox.showerror("Hata", f"Geri yükleme sırasında hata: {e}")

if __name__ == "__main__":
    root = tk.Tk()
    app = ArabicLearningApp(root)
    root.mainloop()
